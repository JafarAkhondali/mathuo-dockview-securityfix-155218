{"version":3,"file":"assets/js/864e8769.9116b8cc.js","mappings":"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","sources":["webpack://dockview-docs/./src/components/ui/reference/types.ts","webpack://dockview-docs/./src/components/ui/reference/docRef.tsx","webpack://dockview-docs/./docs/api/paneview/panelApi.mdx"],"sourcesContent":["export type ExportedTypeFile = Record<string, TypeSystem.Type>;\n\nexport function firstLevelTypes(value: TypeDescriptor.Type | null) {\n    if (!value) {\n        return null;\n    }\n\n    switch (value.type) {\n        case 'array':\n            return firstLevelTypes(value.value);\n        case 'literal':\n            return [];\n        case 'intrinsic':\n            return [];\n        case 'or':\n            return value.values.flatMap(firstLevelTypes);\n        case 'intersection':\n            return value.values.flatMap(firstLevelTypes);\n        case 'predicate':\n            return [];\n        case 'reference': {\n            const result = [];\n            if (\n                value.source.startsWith('dockview') &&\n                !value.refersToTypeParameter\n            ) {\n                result.push(value.value);\n            }\n            if (value.typeArguments) {\n                result.push(...value.typeArguments.flatMap(firstLevelTypes));\n            }\n            return result;\n        }\n        case 'reflection':\n            return firstLevel(value.value);\n        case 'tuple':\n            return value.value.map(codifyType);\n        default:\n            throw new Error('unreachable');\n    }\n}\n\nexport function firstLevel(value: TypeSystem.Type | null) {\n    if (!value) {\n        return [];\n    }\n\n    if (value.kind === 'property') {\n        return firstLevelTypes(value.type);\n    }\n\n    if (value.kind === 'accessor') {\n        return firstLevelTypes(value.value.returnType);\n    }\n\n    if (value.kind === 'method') {\n        return value.signature.flatMap(firstLevel);\n    }\n\n    if (value.kind === 'constructor') {\n        return [];\n    }\n\n    if (value.kind === 'typeLiteral') {\n        const result = [];\n        if (value.properties) {\n            result.push(...value.properties.flatMap(firstLevel));\n        }\n        if (value.signatures) {\n            result.push(...value.signatures.flatMap(firstLevel));\n        }\n        return result;\n    }\n\n    if (value.kind === 'callSignature') {\n        const result = [];\n\n        result.push(\n            ...firstLevelTypes(value.returnType),\n            ...value.typeParameters.flatMap((_) => {\n                return [...firstLevelTypes(_.extends)];\n            }),\n            ...value.parameters.flatMap(firstLevel)\n        );\n\n        return result;\n    }\n\n    if (value.kind === 'parameter') {\n        return firstLevelTypes(value.type);\n    }\n\n    console.log('test', value);\n    throw new Error('unreachable');\n}\n\nexport function codifyType(value: TypeDescriptor.Type | null) {\n    if (!value) {\n        return null;\n    }\n\n    switch (value.type) {\n        case 'array':\n            return `${codifyType(value.value)}[]`;\n        case 'literal':\n            return `'${value.value}'`;\n        case 'intrinsic':\n            return value.value;\n        case 'or':\n            return `${value.values\n                .map((_) => {\n                    const isComparator =\n                        _.type === 'or' || _.type === 'intersection';\n                    const code = codifyType(_);\n                    return isComparator ? `(${code})` : code;\n                })\n                .join(' | ')}`;\n        case 'intersection':\n            return `${value.values\n                .map((_) => {\n                    const isComparator =\n                        _.type === 'or' || _.type === 'intersection';\n                    const code = codifyType(_);\n                    return isComparator ? `(${code})` : code;\n                })\n                .join(' & ')}`;\n        case 'predicate':\n            return `${value.lhs} is ${value.rhs}`;\n\n        case 'reference': {\n            if (value.typeArguments) {\n                return `${value.value}<${value.typeArguments.map(codifyType)}>`;\n            }\n            return `${value.value}`;\n        }\n        case 'reflection':\n            return codify(value.value);\n        case 'tuple':\n            return `[${value.value.map(codifyType).join(', ')}]`;\n        default:\n            throw new Error('unreachable');\n    }\n}\n\nexport function codify(value: TypeSystem.Type | null) {\n    if (!value) {\n        return null;\n    }\n\n    if (value.kind === 'accessor') {\n        const signature = value.value;\n        return `${signature.name}: ${codifyType(signature.returnType)}`;\n    }\n\n    if (value.kind === 'property') {\n        let code = '';\n\n        if (value.flags.isProtected) {\n            code += 'protected ';\n        }\n\n        if (value.flags.isReadonly) {\n            code += 'readonly ';\n        }\n        code += value.name;\n        if (value.flags.isOptional) {\n            code += '?';\n        }\n\n        code += `: ${codifyType(value.type)}`;\n        return code;\n    }\n\n    if (value.kind === 'method') {\n        return value.signature.map(codify).join('\\n');\n    }\n\n    if (value.kind === 'callSignature') {\n        let code = ``;\n\n        if (value.typeParameters.length > 0) {\n            code += '<';\n            code += value.typeParameters.map((typeParameter) => {\n                let typeCode = `${typeParameter.name}`;\n\n                if (typeParameter.extends) {\n                    typeCode += ' extends';\n                    typeCode += ` ${codifyType(typeParameter.extends)}`;\n                }\n\n                if (typeParameter.default) {\n                    typeCode += ' =';\n                    typeCode += ` ${typeParameter.default}`;\n                }\n                return typeCode;\n            });\n            code += '>';\n        }\n\n        code += '(';\n\n        code += value.parameters\n            .map((parameter) => {\n                return codify(parameter);\n            })\n            .join(', ');\n\n        code += `): ${codifyType(value.returnType)}`;\n\n        return code;\n    }\n\n    if (value.kind === 'parameter') {\n        return `${value.name}: ${codifyType(value.type)}`;\n    }\n\n    if (value.kind === 'typeLiteral') {\n        if (value.properties) {\n            return `{\\n${value.properties.map(codify).join(',\\n')}\\n}`;\n        }\n        if (value.signatures) {\n            return value.signatures.map(codify).join('\\n');\n        }\n    }\n\n    if (value.kind === 'constructor') {\n        return '';\n    }\n\n    if (value.kind === 'interface') {\n        return `interface ${value.name} {\\n${value.children\n            .map(codify)\n            .join(',\\n')}\\n}`;\n    }\n\n    if (value.kind === 'class') {\n        return `interface ${value.name} {\\n${value.children\n            .map(codify)\n            .join(',\\n')}\\n}`;\n    }\n\n    if (value.kind === 'typeAlias') {\n        return `type ${value.name} = ${codifyType(value.type)}`;\n    }\n\n    console.log('unreachable', value);\n    throw new Error(`unreachable`);\n}\n\nexport namespace TypeSystem {\n    export type Comment = any;\n\n    export type TypeParameter = {\n        name: string;\n        extends: TypeDescriptor.Type;\n        default: string;\n        comment?: Comment;\n    };\n\n    export type Accessor = {\n        name: string;\n        kind: 'accessor';\n        comment?: Comment;\n        value: TypeSystem.GetSignature;\n    };\n\n    export type GetSignature = {\n        kind: 'getSignature';\n        name: string;\n        returnType: TypeDescriptor.Type;\n        comment?: Comment;\n    };\n\n    export type CallSignature = {\n        kind: 'callSignature';\n        typeParameters: TypeSystem.TypeParameter[];\n        parameters: TypeSystem.Type[];\n        returnType: TypeDescriptor.Type;\n        name: string;\n        comment?: Comment;\n    };\n\n    export type Method = {\n        name: string;\n        kind: 'method';\n        signature: TypeSystem.CallSignature[];\n        comment?: Comment;\n    };\n\n    export type Function = {\n        name: string;\n        kind: 'function';\n        signature: TypeSystem.CallSignature;\n        comment?: Comment;\n    };\n\n    export type Property = {\n        kind: 'property';\n        name: string;\n        type: TypeDescriptor.Type;\n        flags: TypeDescriptor.Flags;\n        comment?: Comment;\n    };\n\n    export type TypeAlias = {\n        name: string;\n        kind: 'typeAlias';\n        typeParameters: TypeSystem.TypeParameter[];\n        type: TypeDescriptor.Type;\n        comment?: Comment;\n    };\n\n    export type Enum = {\n        name: string;\n        kind: 'enum';\n        children: TypeSystem.EnumMember[];\n        comment?: Comment;\n    };\n\n    export type EnumMember = {\n        kind: 'enumMember';\n        name: string;\n        comment?: Comment;\n    };\n\n    export type Class = {\n        name: string;\n        kind: 'class';\n        children: TypeSystem.Type[];\n        comment?: Comment;\n    };\n\n    export type Interface = {\n        name: string;\n        kind: 'interface';\n        children: TypeSystem.Type[];\n        comment?: Comment;\n    };\n\n    export type Parameter = {\n        name: string;\n        kind: 'parameter';\n        type: TypeDescriptor.Type;\n        comment?: Comment;\n    };\n\n    export type Constructor = {\n        kind: 'constructor';\n        name: string;\n        comment?: Comment;\n    };\n\n    export type ConstructorSignature = {\n        kind: 'constructorSignature';\n        name: string;\n        comment?: Comment;\n    };\n\n    export type TypeLiteral = {\n        kind: 'typeLiteral';\n        name: string;\n        signatures?: (ConstructorSignature | TypeSystem.CallSignature)[];\n        properties?: TypeSystem.Property[];\n        comment?: Comment;\n    };\n\n    export type Type =\n        | TypeSystem.Accessor\n        | TypeSystem.GetSignature\n        | TypeSystem.CallSignature\n        | TypeSystem.Method\n        | TypeSystem.Property\n        | TypeSystem.TypeAlias\n        | TypeSystem.Enum\n        | TypeSystem.EnumMember\n        | TypeSystem.Class\n        | TypeSystem.Constructor\n        | TypeSystem.ConstructorSignature\n        | TypeSystem.TypeLiteral\n        | TypeSystem.Parameter\n        | TypeSystem.Interface\n        | TypeSystem.Function;\n}\n\nexport namespace TypeDescriptor {\n    export interface Union {\n        type: 'or';\n        values: TypeDescriptor.Type[];\n    }\n\n    export interface Intrinsic {\n        type: 'intrinsic';\n        value: string;\n    }\n\n    export interface Literal {\n        type: 'literal';\n        value: string;\n    }\n\n    export type Reflection = { type: 'reflection'; value: TypeSystem.Type };\n\n    export interface Reference {\n        type: 'reference';\n        value: string;\n        source: string;\n        typeArguments?: TypeDescriptor.Type[];\n        refersToTypeParameter?: boolean;\n    }\n\n    export interface Array {\n        type: 'array';\n        value: TypeDescriptor.Type;\n    }\n\n    export interface Intersection {\n        type: 'intersection';\n        values: TypeDescriptor.Type[];\n    }\n\n    export interface Predicate {\n        type: 'predicate';\n        lhs: string;\n        rhs: TypeDescriptor.Type;\n    }\n\n    export interface Tuple {\n        type: 'tuple';\n        value: TypeDescriptor.Type[];\n    }\n\n    export type Type =\n        | TypeDescriptor.Union\n        | TypeDescriptor.Intrinsic\n        | TypeDescriptor.Literal\n        | TypeDescriptor.Reflection\n        | TypeDescriptor.Reference\n        | TypeDescriptor.Array\n        | TypeDescriptor.Intersection\n        | TypeDescriptor.Predicate\n        | TypeDescriptor.Tuple;\n\n    export type Flags = {\n        isReadonly?: boolean;\n        isProtected?: boolean;\n        isOptional?: boolean;\n    };\n}\n","import * as React from 'react';\nimport CodeBlock from '@theme/CodeBlock';\nimport './docRef.scss';\n\nexport interface DocRefProps {\n    declaration: string;\n    methods?: string[];\n}\n\nimport docsJson_ from '../../../generated/api.output.json';\nimport { ExportedTypeFile, TypeSystem, codify, firstLevel } from './types';\nconst docsJson = docsJson_ as any as DocsJson;\n\ntype DocsContent = { kind: string; text: string; tag?: string };\ntype DocsTag = { tag: string; content: DocsContent[] };\ntype DocsComment = {\n    summary?: DocsContent[];\n    blockTags?: DocsTag[];\n};\n\ntype Piece = {\n    kind: 'return' | 'paramter' | 'signature' | 'typearg' | 'typearg_default';\n    value: string;\n};\n\ntype Doc = {\n    name: string;\n    code: string;\n    comment?: DocsComment;\n    kind: 'accessor' | 'property' | 'method';\n    pieces: Piece[];\n};\n\ntype DocJson = {\n    kind: string;\n    metadata?: Doc;\n    children: Doc[];\n};\n\ntype DocsJson = {\n    [index: string]: DocJson;\n};\n\nconst newJson = docsJson_ as ExportedTypeFile;\n\nexport const DocumentRef = (props: { value: TypeSystem.Type }) => {\n    const code = React.useMemo(() => {\n        if (!props.value) {\n            return null;\n        }\n\n        switch (props.value.kind) {\n            case 'typeAlias':\n                return codify(props.value);\n            case 'interface':\n                return codify(props.value);\n            case 'class':\n                return codify(props.value);\n            case 'function':\n                return codify(props.value);\n            default:\n                return null;\n        }\n    }, [props.value]);\n\n    if (!code) {\n        return null;\n    }\n\n    return <CodeBlock language=\"tsx\">{code}</CodeBlock>;\n};\n\nexport const Text = (props: { content: DocsContent[] }) => {\n    return (\n        <div className=\"doc-text\">\n            {props.content.map((piece, i) => {\n                switch (piece.kind) {\n                    case 'text': {\n                        return <span key={i}>{piece.text}</span>;\n                    }\n                    case 'code':\n                        return (\n                            <code key={i}>\n                                {piece.text.substring(1, piece.text.length - 1)}\n                            </code>\n                        );\n                    default:\n                        throw new Error(`unhandled piece ${piece.kind}`);\n                }\n            })}\n        </div>\n    );\n};\n\nexport const Tags = (props: { tags: DocsTag[] }) => {\n    return (\n        <div>\n            {props.tags.map((tag, i) => {\n                return (\n                    <div key={i}>\n                        <div>{tag.tag}</div>\n                        <Text content={tag.content} />\n                    </div>\n                );\n            })}\n        </div>\n    );\n};\n\nexport const Summary = (props: { summary: DocsComment }) => {\n    return (\n        <div>\n            <Text content={props.summary.summary ?? []} />\n            {/* <Tags tags={props.summary.blockTags ?? []} /> */}\n        </div>\n    );\n};\n\nexport const Markdown = (props: { children: string }) => {\n    return <span>{props.children}</span>;\n};\n\nconst Row = (props: { doc: TypeSystem.Type }) => {\n    const comment =\n        props.doc.kind === 'accessor'\n            ? props.doc.value.comment\n            : props.doc.comment;\n    return (\n        <tr>\n            <th\n                style={{\n                    width: '40%',\n                    display: 'flex',\n                }}\n            >\n                <div\n                    style={{\n                        display: 'flex',\n                        flexDirection: 'column',\n                        alignItems: 'start',\n                    }}\n                >\n                    <h6\n                        style={{\n                            fontFamily: 'monospace',\n                            fontSize: '1.2em',\n                        }}\n                    >\n                        {props.doc.name}\n                    </h6>\n                    <div\n                        style={{\n                            display: 'flex',\n                            flexDirection: 'column',\n                            alignItems: 'start',\n                        }}\n                    >\n                        {/* <span\n                            style={{\n                                fontSize: '0.75em',\n                                color: 'var(--ifm-color-content-secondary)',\n                            }}\n                        >\n                            {'Type'}\n                        </span>\n                        <span\n                            style={{\n                                color: 'var(--ifm-color-primary)',\n                            }}\n                        >\n                            {doc.type}\n                        </span> */}\n                    </div>\n                </div>\n            </th>\n            <th style={{ width: '60%' }}>\n                {/* <div>{'-'}</div> */}\n                <div>\n                    <div>{comment && <Summary summary={comment} />}</div>\n                    <CodeBlock language=\"tsx\">{codify(props.doc)}</CodeBlock>\n                </div>\n            </th>\n        </tr>\n    );\n};\n\nexport const DocRef = (props: DocRefProps) => {\n    const docs = React.useMemo(\n        () => newJson[props.declaration],\n        [props.declaration]\n    );\n\n    const filteredDocs = React.useMemo(\n        () =>\n            docs.kind === 'class'\n                ? docs.children.filter((child) => {\n                      if (\n                          props.methods &&\n                          !props.methods.includes(child.name)\n                      ) {\n                          return false;\n                      }\n                      return true;\n                  })\n                : [],\n        [docs]\n    );\n\n    if (!docs) {\n        return <span>{`Failed to find docs for '${props.declaration}'`}</span>;\n    }\n\n    return (\n        <table className=\"doc-ref-table\">\n            <tbody>\n                {filteredDocs.map((doc, i) => {\n                    return (\n                        <>\n                            <Row key={i} doc={doc} />\n                            {/* <div>\n                                {firstLevel(doc).map((x) => (\n                                    <span style={{ padding: '0px 2px' }}>\n                                        <DocumentRef value={newJson[x]} />\n                                    </span>\n                                ))}\n                            </div> */}\n                            {/* {doc.pieces?.map((piece) => (\n                                <tr>\n                                    <th colSpan={2}>\n                                        <Piece piece={piece} />\n                                    </th>\n                                </tr>\n                            ))} */}\n                        </>\n                    );\n                })}\n            </tbody>\n        </table>\n    );\n};\n","\n\nexport const frontMatter = {\n\tdescription: 'API',\n\ttitle: 'Panel API',\n\tsidebar_position: 2\n};\nexport const contentTitle = undefined;\nexport const metadata = {\n  \"id\": \"api/paneview/panelApi\",\n  \"title\": \"Panel API\",\n  \"description\": \"API\",\n  \"source\": \"@site/docs/api/paneview/panelApi.mdx\",\n  \"sourceDirName\": \"api/paneview\",\n  \"slug\": \"/api/paneview/panelApi\",\n  \"permalink\": \"/docs/api/paneview/panelApi\",\n  \"draft\": false,\n  \"unlisted\": false,\n  \"editUrl\": \"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api/paneview/panelApi.mdx\",\n  \"tags\": [],\n  \"version\": \"current\",\n  \"sidebarPosition\": 2,\n  \"frontMatter\": {\n    \"description\": \"API\",\n    \"title\": \"Panel API\",\n    \"sidebar_position\": 2\n  },\n  \"sidebar\": \"api\",\n  \"previous\": {\n    \"title\": \"API\",\n    \"permalink\": \"/docs/api/paneview/api\"\n  }\n};\nexport const assets = {\n\n};\n\nimport {jsx as _jsx} from \"react/jsx-runtime\";\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport {DocRef} from '@site/src/components/ui/reference/docRef';\nexport const toc = [];\nfunction _createMdxContent(props) {\n  return _jsx(DocRef, {\n    declaration: \"PaneviewPanelApi\"\n  });\n}\nexport default function MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n"],"names":["codifyType","value","type","values","map","_","isComparator","code","join","lhs","rhs","typeArguments","codify","Error","kind","signature","name","returnType","flags","isProtected","isReadonly","isOptional","typeParameters","length","typeParameter","typeCode","extends","default","parameters","parameter","properties","signatures","children","console","log","newJson","docsJson_","Text","props","_jsx","className","content","piece","i","text","substring","Summary","summary","Row","comment","doc","_jsxs","style","width","display","flexDirection","alignItems","fontFamily","fontSize","CodeBlock","language","DocRef","docs","React","declaration","filteredDocs","filter","child","methods","includes","_Fragment","frontMatter","description","title","sidebar_position","contentTitle","undefined","metadata","assets","toc","_createMdxContent","MDXContent","wrapper","MDXLayout","components"],"sourceRoot":""}