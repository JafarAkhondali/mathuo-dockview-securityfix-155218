{"version":3,"file":"assets/js/6835.f35d1008.js","mappings":"4+CAgBgBA,EACdC,GAEA,IAAMC,GAAkBC,EAAAA,EAAAA,QAA2B,MAcnD,OATA,SAAgBC,GACTA,GAAWA,IAAYF,EAAgBG,UAI5CH,EAAgBG,QAAUD,EAC1BH,EAAYG,GACb,CAGF,CAwEM,IAAME,EACO,oBAAXC,OAAyBC,EAAAA,gBAAkBC,EAAAA,U,SCvGpCC,EAAcC,GAC5B,OAAOC,WAAWD,EAAME,QAAQ,KAAM,IACvC,C,SAKeC,EAAMH,EAAeI,EAAaC,GAChD,OAAOL,EAAQI,EAAMA,EAAMJ,EAAQK,EAAMA,EAAML,CAChD,C,SAKeM,EAASN,GACvB,OAAOA,OACR,C,SAMeO,I,2BAAaC,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,UAAAA,GAC3B,OAAO,SAACf,GACN,cAAkBe,KAAlB,aAAwB,KAAbC,EAAa,QACjBA,IAIc,mBAARA,EACTA,EAAIhB,GAEJgB,EAAIf,QAAUD,EAEjB,CACF,CACF,C,SCVeiB,EACdjB,EACAkB,GAEA,IAAMC,EAAwB,GAE9B,IAAKnB,IAAYkB,GAAelB,IAAYoB,SAASC,KACnD,OAAOF,EAGT,MACED,EAAYI,iBAAiBtB,GAU/B,MAPE,CAJF,EAAQuB,SAAR,EAAkBC,UAAlB,EAA6BC,WAIMC,MAAK,SAAAC,GAAI,MACxC,CAAC,OAAQ,UAAUC,SAASD,EADY,KAI1CR,EAAOU,KAAK7B,GAGd,UACKmB,EACAF,EAAqBjB,EAAQ8B,cAAeZ,GAElD,CAED,SAASa,EAAqBC,GAC5B,8DAA+DA,EAA/D,6FACsDA,EADtD,uJAEmDA,EAFnD,sCAGD,C,SAgDeC,EAAiB,G,IAE/BC,EAAAA,EAAAA,QAEAC,EAAAA,EAAAA,SAEAjB,EAAAA,EAAAA,YAGAkB,EAAAA,EAAAA,uBAEAC,EAAAA,EAAAA,kBAEAC,EAAAA,EAAAA,cAGMC,E,SA7GNrB,EACAsB,GAEA,QAA2B,IAAhBtB,EAIX,OAAOsB,GAAatB,EAAoBqB,cACzC,CAqGwBE,CAAkBvB,EAAakB,IAGtD/B,EAAAA,EAAAA,YAAU,WAKT,GAAE,CAACkC,IAGJ,IF7FqCG,EAO/BC,EA0BAC,EE4DAC,GAAW9C,EAAAA,EAAAA,QAA2B,MAGtC+C,EAAmBC,QAAQT,GAIjC,GFpGqCI,EEwGlC,CACDM,iBAAkB,GAClBC,QAAS,KACTC,MAAO,MFpGHP,GAAQ5C,EAAAA,EAAAA,QAAc2C,IAErBS,EAAAA,EAAAA,UAAQ,WAeb,MAAO,CAJP,WACE,OAAOR,EAAM1C,OACd,EAVD,SAAamD,GAETT,EAAM1C,QADc,mBAAXmD,EACOA,EAAOT,EAAM1C,SAEbmD,CAEnB,EAOF,GAAE,KE2EIC,EAAP,KAAYC,EAAZ,KAWA,GF9EMV,GAAgB7C,EAAAA,EAAAA,QAA0B,KAEzCoD,EAAAA,EAAAA,UAAQ,WAiBb,MAAO,CACLI,sBAjBF,WACE,OAAOX,EAAc3C,QAAQuD,OAAS,CACvC,EAgBCC,4BAdF,WACE,cAA0Bb,EAAc3C,WAAxC,cACEyD,EADgD,WAIlDd,EAAc3C,QAAU,EACzB,EASC0D,qBAPF,SAA8BC,GAC5BhB,EAAc3C,QAAQ4B,KAAK+B,EAC5B,EAOF,GAAE,KEuDDL,EADF,EACEA,sBACAI,EAFF,EAEEA,qBACAF,EAHF,EAGEA,4BAKII,GAAeC,EAAAA,EAAAA,cACnB,WACE,MAA6CT,IAArCH,EAAR,EAAQA,MAAOD,EAAf,EAAeA,QAASD,EAAxB,EAAwBA,iBAClBe,EAAyBf,EAAiB,GAEhD,IAAKE,EACH,MAAM,IAAIc,MAAMjC,EAAqB,UAGvC,IAAKkB,IAAYH,EACf,MAAM,IAAIkB,MAAMjC,EAAqB,YAGvC,IAAIkC,EAA+B,CAAEC,IAAK,EAAGC,KAAM,GACnD,GAAIJ,EAAwB,CAC1B,IAAQK,EAA0BL,EAA1BK,WACRH,EAAgB,CACdC,IAFgCH,EAAdM,UAGlBF,KAAMC,EAET,KAAM,CACL,IAAQE,EAAqBpD,EAArBoD,QACRL,EAAgB,CACdC,IAF2BhD,EAAZqD,QAGfJ,KAAMG,EAET,CAED,IAAIE,EAA+B,CAAEL,KAAM,EAAGD,IAAK,GACnD,GAAIH,EAAwB,CAC1B,MACE7C,EAAaI,iBAAiByC,GADxBU,EAAR,EAAQA,gBAAiBC,EAAzB,EAAyBA,eAGzBF,EAAgB,CACdL,KAAM7D,EAAcmE,IAAoB,EACxCP,IAAK5D,EAAcoE,IAAmB,EAEzC,CAEDvC,EACE,CACEe,MAAAA,EACAD,QAASA,EACTD,iBAAAA,EACA2B,MAAO9B,EAAS5C,SAElBgE,EACAO,EAEH,GACD,CAACnB,EAAKlB,EAAUjB,EAAa2B,EAAUC,IAKnC8B,GAAoBd,EAAAA,EAAAA,cACxB,WACE,MAA6CT,IAArCJ,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,MAAOF,EAAxB,EAAwBA,iBAExB,IAAKE,EACH,MAAM,IAAIc,MAAMjC,EAAqB,UAEvC,IAAKkB,IAAYH,EAEf,MAAM,IAAIkB,MAAMjC,EAAqB,YAGvC,GAAIQ,EAAgB,CAYlB,IAXA,IAAIsC,GAAqB,EAUnBC,EAAW,IAAIvC,GATI,WAClBsC,EAKLhB,IAJEgB,GAAqB,CAKxB,IAGD,MAAsB,CAAC5B,EAASC,EAAO9B,SAASC,MAAhD,eAAuD,CAAlD,IAAMrB,EAAO,KACZA,GAAS8E,EAASC,QAAQ/E,EAC/B,CAED2D,GAAqB,WACnB,cAAsB,CAACV,EAASC,EAAO9B,SAASC,MAAhD,eAAuD,CAAlD,IAAMrB,EAAO,KACZA,GAAS8E,EAASE,UAAUhF,EACjC,CACD8E,EAASG,YACV,GACF,CAGD,IADA,IACA,E,iBAAWjF,EAAAA,EAAAA,MACTA,EAAQkF,iBAAiB,SAAUrB,GAEnCF,GAAqB,kBACnB3D,EAAQmF,oBAAoB,SAAUtB,EADnB,G,EAHvB,IADgC,CAAC3C,GAAJ,OAAqB8B,MAClD,aAA+C,GAOhD,GACD,CACEK,EACAM,EACAE,EACA3C,EACAqB,EACAO,IAMEsC,GAAyCtB,EAAAA,EAAAA,cAC7C,SAACuB,EAA8BC,GACzBpD,GAAWmD,GAAYA,IAAaC,IACtC7B,IACAmB,IACAf,IAEH,GACD,CAACJ,EAA6BmB,EAAmBf,EAAc3B,IAI3DqD,EAAW3F,GACfkE,EAAAA,EAAAA,cACE,SAAAZ,GACE,IAAesC,EAAkBnC,IAAzBH,MAGRI,GAAI,SAAAX,GAAK,YACJA,EADI,CAEPO,MAAAA,GAFO,IAMTkC,EAAuCI,EAAetC,EACvD,GACD,CAACG,EAAKC,EAAK8B,KAITK,GAAsB3B,EAAAA,EAAAA,cAC1B,SAAgC9D,GAC9B,IAAMgD,EAAmB/B,EAAqBjB,EAASkB,GAEjD6C,EAAyBf,EAAiB,GAEhD,GAAIe,EAAwB,CAE1B,IAAM2B,EAAWxE,EAAaI,iBAC5ByC,GACA2B,SAGA,CAAC,WAAY,WAAY,SAAS9D,SAAS8D,IAC3CrD,IAGA0B,EAAuB4B,MAAMD,SAAW,WAO3C,CACD,OAAO1C,CACR,GACD,CAAC9B,EAAamB,IAKVuD,EAAahG,GACjBkE,EAAAA,EAAAA,cACE,SAAAb,GAEE,IAAMD,EAAmByC,EAAoBxC,GAE5B4C,EAAoBxC,IAA7BJ,QAGRK,GAAI,SAAAX,GAAK,YACJA,EADI,CAEPM,QAAAA,EACAD,iBAAAA,GAHO,IAOToC,EAAuCS,EAAiB5C,EACzD,GACD,CAACI,EAAKC,EAAK8B,EAAwCK,KAMjDK,EAAmB,MAAGxD,GAAH,MAAGA,EAAeyD,eAAlB,EAAGzD,EAAeyD,YAuC3C,OAtCA7F,GAA0B,WACnB4F,GAGLxC,GAAI,SAAAX,GAAK,YACJA,EADI,CAEPK,iBAAkByC,EAAoBK,IAF/B,GAIV,GAAE,CAACA,EAAqBxC,EAAKmC,IAE9BvF,GAA0B,WAQxB,OAPIgC,IAEGqB,KACHqB,KAIG,WACDrB,KACFE,GAEH,CACF,GAAE,CACDvB,EACAqB,EACAqB,EACAnB,IAIFvD,GAA0B,WACpBgC,GAEF2B,GAEH,IAEM,CACL+B,WAAAA,EACAL,SAAAA,EACA1C,SAAAA,EACAkB,uBAAwBV,IAAML,iBAAiB,IAAM,KAExD,CC9XD,IAAMgD,GAAeC,EAAAA,EAAAA,eAAc,CAAC,G,SAWpBC,EAAc,G,IAAEC,EAAAA,EAAAA,SAAUC,EAAAA,EAAAA,cAGlCC,GAAiBvC,EAAAA,EAAAA,cACrB,SAAkBwC,GAGhB,OAFAF,EAAcnG,QAAQsG,IAAID,GAEnB,kBAAMF,EAAcnG,QAAQuG,OAAOF,EAAnC,CACR,GACD,CAACF,IAGH,OAAOK,EAAAA,EAAAA,eACLT,EAAaU,SACb,CAAEnG,MAAO8F,GACTF,EAEH,C,SAqCeQ,EAAS,G,IAAEC,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,eAAgBC,EAAAA,EAAAA,cAG3C7D,GAAUlD,EAAAA,EAAAA,QAAoB,MAC9BmD,GAAQnD,EAAAA,EAAAA,QAAoB,MAG5BqG,GAAgBrG,EAAAA,EAAAA,QAAsB,IAAIgH,KAI1CC,GAAqBC,EAAAA,EAAAA,YAAWjB,GAIhCkB,GAAgCpD,EAAAA,EAAAA,cACpC,SAAuCqD,GACrC,IAAMC,EAASD,EAAMC,OAEfC,EACJpE,EAAQhD,SAAWgD,EAAQhD,QAAQqH,SAASF,GACxCG,EAAiBrE,EAAMjD,SAAWiD,EAAMjD,QAAQqH,SAASF,GAEzDI,EAxDZ,SACEpB,EACAe,GAEA,cAAgDf,KAAhD,aACE,KAAKc,EADwD,QAAlDA,+BACwBC,GACjC,OAAO,EAIX,OAAO,CACR,CA6C4CM,CACrCrB,EAAcnG,QACdkH,GASF,OAJII,GAAkBC,GACpBpB,EAAcnG,QAAQyH,SAAQ,mBAAoBC,EAApB,EAAGA,aAAH,KAI7BN,IAAqBE,GAAkBC,CAE3C,GACD,CAACvE,EAASC,EAAOkD,IA6DnB,OAzDA/F,EAAAA,EAAAA,YAAU,WACR,GAAkC,mBAAvB2G,EAMX,OAAOA,EAAmB,CACxBE,8BAAAA,EACAS,WAAY,WAMNb,GACFA,GAEH,GAEJ,GAAE,CACDE,EACAE,EACAJ,EACAV,KAIF/F,EAAAA,EAAAA,YAAU,WAGR,MADyBuG,IAAWC,GADU,mBAAvBG,GAavB,OADA5F,SAAS8D,iBAAiB,QAAS0C,GAAa,GACzC,kBAAMxG,SAAS+D,oBAAoB,QAASyC,GAAa,EAAzD,EAPP,SAASA,EAAYT,GACfD,EAA8BC,IAChCN,GAEH,CAIF,GAAE,CACDD,EACAC,EACAK,EACAF,KAIF3G,EAAAA,EAAAA,YAAU,WACHuG,GACHR,EAAcnG,QAAQyH,SAAQ,mBAAoBC,EAApB,EAAGA,aAAH,GAEjC,GAAE,CAACf,IAEG,CACLiB,wBAAyB,CACvB5E,QAAAA,EACAC,MAAAA,GAEFkD,cAAAA,EAEH,C,IC7LK0B,EAAwC,CAC5C5D,IAAK,SACLC,KAAM,QACN4D,OAAQ,MACRC,MAAO,OACPC,OAAQ,UAGJC,EAAAA,WACJ,WACWvG,EACAwG,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,G,KARA/G,UAAAA,E,KACAwG,cAAAA,E,KACAC,kBAAAA,E,KACAC,cAAAA,E,KACAC,sBAAAA,E,KACAC,aAAAA,E,KACAC,qBAAAA,E,KACAC,cAAAA,E,KACAC,YAAAA,EARA,KAAA/G,KAAAA,EACA,KAAAwG,SAAAA,EACA,KAAAC,aAAAA,EACA,KAAAC,SAAAA,EACA,KAAAC,iBAAAA,EACA,KAAAC,QAAAA,EACA,KAAAC,gBAAAA,EACA,KAAAC,SAAAA,EACA,KAAAC,OAAAA,CACP,C,2BAEJC,OAAA,SAAOpI,GACL,OAAOA,GAASqI,KAAKF,OAAS,GAAK,EACpC,E,EAEDG,oBAAA,SAAoBC,GAClB,OAAOF,KAAKR,eAAiBU,EAAKV,YACnC,E,EAnBGF,GAsBN,SAASa,EACPpH,EACAqH,QAAAA,IAAAA,IAAAA,GAAY,GAEZ,IAAMZ,EAAe,CAAC,OAAQ,SAASxG,SAASD,GAEhD,OAAO,IAAIuG,EACTvG,EACAqH,EAAYD,EAAejB,EAAkBnG,IAAO,GAAS,KAC7DyG,EACAA,EAAe,QAAU,SACzBA,EAAe,SAAW,QAC1BA,EAAe,OAAS,MACxBA,EAAe,MAAQ,OACd,WAATzG,GACC,CAAC,QAAS,UAAUC,SAASD,GAEjC,CAKM,IAAMsH,EAAY,CACvB/E,IAAK6E,EAAW,OAChBhB,OAAQgB,EAAW,UACnB5E,KAAM4E,EAAW,QACjBf,MAAOe,EAAW,UAGPG,EAAI,KACXD,EADW,CAOfhB,OAAQc,EAAW,YChEfI,EAAQ,CAAC,MAAO,OAAQ,SAAU,SAM3BC,EAAb,WAME,WAAYC,GACV,O,KANFnF,SAAAA,E,KACAC,UAAAA,E,KACA6D,WAAAA,E,KACAD,YAAAA,EAGSuB,OAAOC,OAAOX,KAAMS,EAC5B,CARH,SAeSG,mBAAP,SAA0BC,GACxB,IAAOC,EAAkBD,EAAzB,GAAiBE,EAAQF,EAAzB,SAEA,IAAKC,EACH,MAAM,IAAI1F,MACR,8DAQJ,IAJA,IAIA,EAJM7C,EAAyBmI,OAAOM,YACpCT,EAAMU,KAAI,SAAAf,GAAI,MAAI,CAACA,EAAMY,EAAMZ,GAAjB,KAGhB,IAA2Ba,KAA3B,aACE,IAD+B,IAC/B,EADSG,EAAsB,QAC/B,IAAmBX,KAAnB,aAA0B,KAAfL,EAAe,QACxB3H,EAAO2H,GAAQiB,KAAKpJ,IAAIQ,EAAO2H,GAAOgB,EAAahB,GACpD,CAGH,OAAO,IAAIM,EAAcjI,EAC1B,EAnCH,oCAyCE,W,WACE,OAAOgI,EAAMa,OAAM,SAAAlB,GAAI,OAAI,EAAKA,IAAS,CAAlB,GACxB,GA3CH,yBAiDE,W,WACE,OAAOQ,OAAOM,YACZT,EAAMc,QAAO,SAAAnB,GAAI,OAAI,EAAKA,GAAQ,CAAjB,IAAoBe,KAAI,SAAAf,GAAI,MAAI,CAACA,EAAM,EAAKA,GAAhB,IAEhD,KArDH,KCLA,SAASoB,I,2BAAuBC,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,UAAAA,GAC9B,OAAOA,EAAeC,QACpB,SAACC,EAAKC,GAAN,OACED,GAAOC,EAAgBhK,EAAcgK,GAAkB,EADzD,GAEA,EAEH,C,SAWeC,EAAe,GAQ7B,MAAO,CAAErG,IAPTA,EAAAA,IAOcC,KANdA,EAAAA,KAMoB6D,MALpBA,EAAAA,MAK2BD,OAJ3BA,EAAAA,OAImCyC,MAHnCA,EAAAA,MAG0CC,OAF1CA,EAAAA,OAGD,CAED,IAAMC,EAAiB,CACrBxG,IAAK,EACLC,KAAM,EACN6D,MAAO,EACPD,OAAQ,EACRyC,MAAO,EACPC,OAAQ,GAOGE,EAAb,WAuHE,WAAsBC,GACpB,YADoBA,IAAAA,IAAAA,EAA2B,CAAC,G,KAtHlD1G,SAAAA,E,KACAC,UAAAA,E,KACA6D,WAAAA,E,KACAD,YAAAA,E,KACAyC,WAAAA,E,KACAC,YAAAA,EAkHSnB,OAAOC,OAAOX,KAAM8B,EAAOE,EACnC,CAzHH,EAYSC,OAAP,SAAcD,GACZ,OAAO,IAAID,EAAOC,EACnB,EAdH,EAqBSE,YAAP,SACE9K,EACA+K,QAAAA,IAAAA,IAAAA,EAOI,CAAC,GAEL,MAIIA,EAJJ,IACEC,cAAAA,OADF,aAEE9J,YAAAA,OAFF,MAEgBf,OAFhB,MAGE8K,eAAAA,OAHF,SAQIL,EAAiB,IAAID,EAFFJ,EAAevK,EAAQkL,0BAI9C,IAAKF,EAAe,CAClB,MAYI9J,EAAYI,iBAAiBtB,GAX/BwK,EADF,EACEA,MACAC,EAFF,EAEEA,OACAU,EAHF,EAGEA,UACAC,EAJF,EAIEA,WACAC,EALF,EAKEA,YACAC,EANF,EAMEA,UACAC,EAPF,EAOEA,aACAC,EARF,EAQEA,YACAC,EATF,EASEA,aACAC,EAVF,EAUEA,WACAC,EAXF,EAWEA,cAyBFf,EAAS,IAAID,EAAJ,KACJC,EADI,CAEPJ,MAvBc,eAAdW,EACI7K,EAAckK,GACdN,EACEM,EACAY,EACAC,EACAG,EACAC,GAiBNhB,OAbc,eAAdU,EACI7K,EAAcmK,GACdP,EACEO,EACAa,EACAC,EACAG,EACAC,KAQT,CAED,IAAKV,EAAgB,CACnB,IAAMW,EAAiBhB,EAAOJ,MAAQxK,EAAQ6L,YACxCC,EAAkBlB,EAAOH,OAASzK,EAAQ+L,aAChD,OAAOnB,EAAOoB,UAAU,CACtBhE,MAAO4D,EACP7D,OAAQ+D,GAEX,CAED,OAAOlB,CACR,EAhGH,EAqGSqB,MAAP,WACE,OAAO,IAAItB,CACZ,EAvGH,EA6GSuB,WAAP,SAAkBhL,G,MACViL,EAAgB,eACpBjL,OADoB,EACpBA,EAAaE,SAAS+K,kBADF,QAEpBjL,OAFoB,EAEpBA,EAAaE,SAASgL,gBACxB,QACED,EAAAA,EAAoB,CAAC,EADvB,IAAQN,YAAarB,OAArB,MAA6B,EAA7B,MAAgCuB,aAActB,OAA9C,MAAuD,EAAvD,EAGA,OAAO,IAAIE,EAAO,CAAEH,MAAAA,EAAOC,OAAAA,EAAQzC,MAAOwC,EAAOzC,OAAQ0C,GAC1D,EArHH,2BAqIE4B,SAAA,WACE,OAAO9B,EAAe3B,KACvB,EAvIH,EAmJE0D,MAAA,SAAMC,GACJ,IAAMtM,EAAU2I,KAAKyD,WACrB,OAAO,IAAI1B,EAAJ,KACF1K,EACmC,mBAA3BsM,EACPA,EAAuBtM,GACvBsM,GAEP,EA3JH,EAiKEP,UAAA,SAAUpB,GAKR,IAJA,IAAMzJ,EAASyH,KAAKyD,WAIpB,MAFgB/C,OAAOkD,QAAQ5B,GAE/B,eAAqC,CAAhC,WAAOjJ,EAAP,KAAapB,EAAb,KACH,GAAIoB,KAAQsH,EAAW,CAErB,IAAMwD,EAAYxD,EAAUtH,GAE5BR,EAAOQ,IAAS8K,EAAU9D,OAAOpI,GAEjCY,EAAOsL,EAAUrE,aAAe,QAAU,WAAa7H,CACxD,MAECY,EAAOQ,IAASpB,GAAS,CAE5B,CAED,OAAO,IAAIoK,EAAOxJ,EACnB,EArLH,EA4LEuL,UAAA,SAAUC,GACR,OAAO,IAAIvD,EAAc,CACvBlF,IAAKyI,EAAMzI,IAAM0E,KAAK1E,IACtB6D,OAAQa,KAAKb,OAAS4E,EAAM5E,OAC5B5D,KAAMwI,EAAMxI,KAAOyE,KAAKzE,KACxB6D,MAAOY,KAAKZ,MAAQ2E,EAAM3E,OAE7B,EAnMH,EAyME4E,SAAA,SACEC,GAIA,IAFA,IAAM1L,EAASyH,KAAKyD,WAEpB,MADmB/C,OAAOwD,OAAO7D,GACjC,eAAoC,CAA/B,IAAMwD,EAAS,KAClBtL,EAAOsL,EAAU9K,MAAQkL,EAAOJ,EAAWtL,EAAOsL,EAAU9K,MAC7D,CACD,OAAO,IAAIgJ,EAAOxJ,EACnB,EAlNH,wBA8HE,WACE,OAAOyH,KAAK4B,MAAQ5B,KAAK6B,MAC1B,KAhIH,KCtCasC,EAAb,WAKE,WACkBC,EACAC,EAChBC,EACAC,EACiB9D,G,KAJD2D,aAAAA,E,KACAC,eAAAA,E,KAGC5D,aAAAA,E,KATT+D,oBAAAA,E,KACFC,mBAAoC,K,KACpCC,wBAAgD,KAGtC,KAAAN,QAAAA,EACA,KAAAC,UAAAA,EAGC,KAAA5D,QAAAA,EAEjBT,KAAK2E,kBAAkBL,EAAeC,EACvC,CAbH,2BAoBUI,kBAAA,SACNL,EACAC,GAGA,GAAKA,EAAL,CAMA,IAAMK,EAGuB,mBAApBL,EACHA,EAAgBvE,KAAKoE,QAAQrL,MAC7BwL,EAGNvE,KAAKwE,eAAiBF,EAAcZ,MAAM,CACxCpJ,MAAO,EAAF,GACAgK,EAAchK,MACdsK,IAdN,MAFC5E,KAAKwE,eAAiBF,CAmBzB,EA7CH,EAgESO,eAAA,SAAeC,GAEpB,QAFoBA,IAAAA,IAAAA,EAAkB,GAElC9E,KAAKyE,oBAA0C,IAApBK,EAC7B,OAAO9E,KAAKyE,mBAGd,IAAQL,EAAuCpE,KAAvCoE,QAASC,EAA8BrE,KAA9BqE,UAAWG,EAAmBxE,KAAnBwE,eACpBnK,EAA0BmK,EAA1BnK,QAASC,EAAiBkK,EAAjBlK,MAAOyB,EAAUyI,EAAVzI,MAChByD,EACN4E,EADM5E,aAAcI,EACpBwE,EADoBxE,gBAAiBF,EACrC0E,EADqC1E,iBAAkB3G,EACvDqL,EADuDrL,KAAMwG,EAC7D6E,EAD6D7E,SAGzDhH,EAASwJ,EAAOsB,QAWtB9K,EAAOgH,EAASxG,MACdsB,EAAQtB,GAAQqL,EAAQrE,OAAOC,KAAKS,QAAQpG,SAG9C9B,EAAOQ,GACLR,EAAOgH,EAASxG,MAAQqL,EAAQrE,OAAOzF,EAAM8J,EAAQ3E,WAKvD,IAAMsF,EAAuC,EAArB/E,KAAKS,QAAQ1E,MAGjCiJ,EACF3K,EAAQuF,IACPtF,EAAMoF,GAAoB3D,EAAM2D,IACjCqF,EAEEE,EACF5K,EAAQuF,IACPvF,EAAQqF,GAAoB3D,EAAM2D,IACnCqF,EAQF,GANKV,EAAUvE,SAEbkF,GAAY1K,EAAMoF,GAClBuF,GAAY3K,EAAMoF,IAGhB2E,EAAUxE,SAAU,CACtB,IAAMqF,GAAa1F,EAAea,EAAU/E,IAAM+E,EAAU9E,MAAMxC,KAC5DoM,GAAa3F,EAAea,EAAUlB,OAASkB,EAAUjB,OAC5DrG,KAOHR,EAAO2M,GAAapN,EAClBuC,EAAQ6K,GACN7K,EAAQqF,GAAoB,EAC5BpF,EAAMoF,GAAoB,EAC1BoF,EACFE,EACAC,GAIF1M,EAAO4M,GAAa5M,EAAO2M,GAAa5K,EAAMoF,EAC/C,KAAM,CACL,IAAM0F,EAAMf,EAENgB,EAAehL,EAAQ+K,EAAIrM,MAK3BuM,EACJD,EAAeL,EACXA,EAAWK,EACXA,EAAeJ,EACfA,EAAWI,EACX,EAON9M,EAAO6M,EAAIrM,MAAQjB,EACjBuN,EAAeP,EAAkBQ,EACjCN,EACAC,GAIF1M,EAAO6M,EAAI7F,SAASxG,MAClBR,EAAO6M,EAAIrM,MAAQsL,EAAUtE,OAAOzF,EAAMoF,GAC7C,CAGDnH,EAAOqJ,MAAQrJ,EAAO6G,MAAQ7G,EAAOgD,KACrChD,EAAOsJ,OAAStJ,EAAO4G,OAAS5G,EAAO+C,IAGvC,IAAMiK,EAAcxD,EAAOE,OAAO1J,GAMlC,OAJwB,IAApBuM,IACF9E,KAAKyE,mBAAqBc,GAGrBA,CACR,EAnLH,EAmPUC,wBAAA,WACN,IAAQC,EAAczF,KAAKS,QAAnBgF,UAER,OAAOzF,KAAK6E,iBACTb,UAAS,SAAC9D,EAAMvI,GAAP,OAAkBA,EAASuI,EAAKH,OAAO0F,EAAvC,IACT/B,OAAM,gBAAG9B,EAAH,EAAGA,MAAOC,EAAV,EAAUA,OAAV,MAAwB,CAC7BD,MAAOA,EAAoB,EAAZ6D,EACf5D,OAAQA,EAAqB,EAAZ4D,EAFZ,GAIV,EA5PH,EAkQSC,oBAAA,SAAoBH,GACzB,GAAIvF,KAAK0E,0BAA4Ba,EACnC,OAAOvF,KAAK0E,wBAGd,IAAMJ,EAAgBtE,KAAKwE,eAAed,MAAM,CAC9CpJ,MAAOiL,GAAevF,KAAKwF,4BAGvB/E,EAAUD,EAAcI,mBAC5B0D,EAAcqB,gCAOhB,OAJKJ,IACHvF,KAAK0E,wBAA0BjE,GAG1BA,CACR,EApRH,qBAkDE,WACE,OAAUT,KAAKoE,QAAQrL,KAAvB,KAC0B,WAAxBiH,KAAKqE,UAAUtL,KACX,SACA,CAAC,SAAU,SAASC,SAASgH,KAAKqE,UAAUtL,MAC5C,MACA,QAEP,GA1DH,2BAyLE,WACE,IAAQyG,EAAiBQ,KAAKqE,UAAtB7E,aACR,EACEQ,KAAKwE,eADCoB,EAAR,EAAQA,sBAAuBC,EAA/B,EAA+BA,uBAG/B,OACGrG,GAAgBoG,IACfpG,GAAgBqG,CAErB,GAlMH,yBAuME,WACE,OAAO7F,KAAK0F,sBAAsBI,mBACnC,GAzMH,0BA8ME,WACE,IAAMP,EAAcvF,KAAK6E,iBAGnBzB,EAFmBpD,KAAK0F,oBAAoBH,GAEfQ,cACnC,IAAK,IAAM7F,KAAQkD,EAEjBA,EAAUlD,IAASkD,EAAUlD,GAG/B,OAAOqF,EAAYnC,UAAUA,GAAW4C,OACzC,GAzNH,+BA8NE,W,eAKQC,EAAmBjG,KAAK0F,sBAU9B,OARA,kBACEhF,OAAOkD,QAAQqC,EAAiBF,eAC7B9E,KACC,gBAAEf,EAAF,KAAQvI,EAAR,WAAmB,CAAC0I,EAAUH,GAAwBvI,EAAtD,IAED0J,QAAO,gBAAEnB,EAAF,YAAY,EAAKkE,QAAQnE,oBAAoBC,EAA7C,IACPgG,MAAK,kBAAIC,EAAJ,iBAAuBA,CAAvB,UANV,EACE,EAKqC,IANvC,EAM6C,IAN7C,IAQ2B,IAC5B,KA9OH,KAuRaC,EAAb,Y,QAAA,yD,EAAA,G,EAAA,G,sEAAA,YACEvB,eAAA,WACE,MAA2B7E,KAAKwE,eAAxBnK,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,MAEX/B,EAASwJ,EAAOsB,QAStB,OAPA9K,EAAO+C,IAAMjB,EAAQiB,IAAMjB,EAAQwH,OAAS,EAAIvH,EAAMuH,OAAS,EAC/DtJ,EAAO4G,OAAS5G,EAAO+C,IAAMhB,EAAMuH,OACnCtJ,EAAOgD,KAAOlB,EAAQkB,KAAOlB,EAAQuH,MAAQ,EAAItH,EAAMsH,MAAQ,EAC/DrJ,EAAO6G,MAAQ7G,EAAOgD,KAAOjB,EAAMsH,MACnCrJ,EAAOqJ,MAAQrJ,EAAO6G,MAAQ7G,EAAOgD,KACrChD,EAAOsJ,OAAStJ,EAAO4G,OAAS5G,EAAO+C,IAEhC/C,CACR,EAdH,GAAqC4L,GChQrC,IAAMkC,EAAkC,CACtCvJ,SAAU,WACVwJ,WAAY,YACZ/K,KAAM,KACN6D,MAAO,KACP9D,IAAK,KACL6D,OAAQ,M,ICbGoH,EAAb,WACE,WACkBC,EACRC,EACAjC,G,KAFQgC,gBAAAA,E,KACRC,YAAAA,E,KACAjC,oBAAAA,EAFQ,KAAAgC,WAAAA,EACR,KAAAC,OAAAA,EACA,KAAAjC,eAAAA,CACN,CALN,EAUSkC,0BAAP,SACEC,GAEA,MAAaA,EAAKC,MAAM,KAAnBT,EAAL,KAAQU,EAAR,KAKMzC,EAAU/D,EAAU8F,GAU1B,MAAO,CAAC/B,EARE,WAANyC,EACUvG,EAAKjB,OACR+E,EAAQ5E,aACC,UAANqH,EAAgBvG,EAAKhF,IAAMgF,EAAKnB,OAE1B,UAAN0H,EAAgBvG,EAAK/E,KAAO+E,EAAKlB,MAIhD,EA7BH,EAoCS6C,OAAP,SACEuC,EACAiC,GAGA,IAAMhG,EAAmB,CACvB1E,MAAO0K,EAAOK,YACdrB,UAAWgB,EAAOM,gBAClB1M,QAASoM,EAAOO,eAKlB,SAASC,EAAoBC,QAAAA,IAAAA,IAAAA,EAAoBT,EAAOU,WACtD,MACEZ,EAAWG,0BAA0BQ,GADhC9C,EAAP,KAAgBC,EAAhB,KAGM+C,EACJ/G,EAAU+D,EAAQ5E,aAAeiH,EAAOY,QAAUZ,EAAOa,SAGrDC,GACFnD,EAAQ5E,cAAgBgF,EAAeoB,uBACxCxB,EAAQ5E,cAAgBgF,EAAeqB,uBAG1C,SAAS2B,EACPpD,EACAC,GAEA,OAAO,IAAIF,EACTC,EACAC,EACAG,EACAiC,EAAOlC,gBACP9D,EAEH,CAGD,IAAIgH,EAAoB,GA0DxB,OAzDAA,EAAK,GAAKD,EAAcpD,EAASC,GACjCoD,EAAK,GAAKD,EACRpD,EACAC,EAAUxE,SAAWuH,EAAgB9G,EAAKjB,QAE5CoI,EAAK,GAAKD,EACRpD,EACA9D,GACG+D,EAAU9E,SAASM,SAChBuH,EAAc7H,SACd8E,EAAU9E,UACZxG,OAGN0O,EAAK,GAAKD,EACRJ,EACAG,EAAkBnD,EAAU9D,EAAK8D,EAAQ7E,SAASxG,OAEpD0O,EAAK,GAAKD,EAAcJ,EAAe9G,EAAKjB,QAC5CoI,EAAK,GAAKD,EACRJ,EACAG,EAAkBjH,EAAK8D,EAAQ7E,SAASxG,MAAQqL,GAElDqD,EAAK,GAAKD,EACRnH,EAAU+G,EAAc7H,SAASxG,MACjCwO,EAAkBnD,EAAU9D,EAAK8D,EAAQ7E,SAASxG,OAEpD0O,EAAK,GAAKD,EACRnH,EAAU+G,EAAc7H,SAASxG,MACjCuH,EAAKjB,QAEPoI,EAAK,GAAKD,EACRnH,EAAU+G,EAAc7H,SAASxG,MACjCwO,EAAkBjH,EAAK8D,EAAQ7E,SAASxG,MAAQqL,GAElDqD,EAAK,GAAKD,EAAcnH,EAAU+D,EAAQ7E,SAASxG,MAAOsL,GAC1DoD,EAAK,IAAMD,EACTnH,EAAU+D,EAAQ7E,SAASxG,MAC3BsL,EAAUxE,SAAWuH,EAAgB9G,EAAKjB,QAE5CoI,EAAK,IAAMD,EACTnH,EAAU+D,EAAQ7E,SAASxG,MAC3BuH,GACG+D,EAAU9E,SAASM,SAChBuH,EAAc7H,SACd8E,EAAU9E,UACZxG,OAKN0O,EAAOA,EAAKpG,QACV,SAAA8F,GAAS,OACPA,EAAUR,OAASF,EAAOU,WAC1BV,EAAOiB,mBAAmB1O,SAASmO,EAAUR,KAFtC,GAMZ,CAGD,MAAyB,WAArBF,EAAOU,UACF,IAAIZ,EAAJ,CAEH,IAAIH,EACF9F,EAAKjB,OACLiB,EAAKjB,OACLmF,EACAiC,EAAOlC,gBACP9D,IAPC,OASAwG,EACER,EAAOY,QADU,IACCZ,EAAOa,UAGhCb,EACAjC,GAIG,IAAI+B,EAAWU,IAAuBR,EAAQjC,EACtD,EA9JH,2BAgKUmD,uBAAA,SAAuBzH,GAC7B,OAAOF,KAAKwG,WAAWnF,QAAO,SAAA8F,GAAS,OAAIA,EAAU/C,UAAYlE,CAA1B,GACxC,EAlKH,EAoKU0H,2BAAA,WACN,OAAO5H,KAAKwG,WAAWqB,MAAK,SAAAV,GAAS,OAAIA,EAAUW,aAAd,GACtC,EAtKH,EAwKUC,mCAAA,WASN,OARqD/H,KAAKwG,WACvDvF,KAAI,SAAAkG,GAAS,MAAK,CACjBA,UAAAA,EACAnB,QAASmB,EAAUa,eAFP,IAKb9B,MAAK,SAACC,EAAGU,GAAJ,OAAUA,EAAEb,QAAUG,EAAEH,OAAxB,IANR,GAASmB,SASV,EAlLH,EAoLUc,sBAAA,WACN,OAAKjI,KAAKyG,OAAOyB,KAKflI,KAAK4H,8BACL5H,KAAK+H,qCALE/H,KAAKwG,WAAW,EAO1B,EA7LH,EAyMU2B,mBAAA,SAAmBhB,GACzB,MAAuBnH,KAAKyG,OAApByB,EAAR,EAAQA,KAAME,EAAd,EAAcA,KAGd,IAAKF,GAAQE,GAAQjB,aAAqBf,EACxC,OAAO,EAKT,IAAMiC,EAAuBrI,KAAK2H,uBAAuBR,EAAU/C,SAGnE,GAD8C,IAA5CiE,EAAqBC,QAAQnB,IACWA,EAAUW,cAClD,OAAO,EAGT,IAAMS,EAA+BF,EAAqBR,MACxD,SAAAV,GAAS,OAAKA,EAAUW,aAAf,IAEX,IAAKS,EACH,OAAO,EAET,IAAMC,EACJD,EAA6BC,oBAC/B,IAAKA,EACH,OAAO,EAGT,IAIIzI,EAJEkG,EAAmBkB,EAAUzB,sBAG3BrB,EAAc8C,EAAd9C,UAoBR,OAdEtE,EAHAoH,EAAUI,iBACVgB,IAAiCpB,EAExBqB,EAAoB1I,QAAU,EAAI,EAGzCuE,IAAc/D,EAAK/E,MAClB,CAAC+E,EAAKhF,IAAKgF,EAAKjB,QAAQrG,SAASqL,IAChCmE,EAAoB1I,QACjB,EACD,EAKgBmG,EAAiBuC,EAAqBzP,MAErCgH,CAC1B,EA9PH,EAgQU0I,UAAA,SACNlD,EACA4B,EACA9L,EACAO,GAEA,IAAM8M,EAAgC,CACpCpC,WAAY,4BAGRvK,E,SDzPRyI,EACA2C,EACAL,G,MAEA,GAAIK,EAAU/C,QAAQvE,SACpB,OAAOwG,EAGT,IAAQ/L,EAA0BkK,EAA1BlK,MAAOD,EAAmBmK,EAAnBnK,QAAS0B,EAAUyI,EAAVzI,MAElB4M,EAAexB,EAAU/C,QAAQ1E,iBACjC6H,EAAkBlN,EAAQsO,GAAgBrO,EAAMqO,GAEhD5Q,EAAM+O,EAAc/K,EAAM4M,GAAgB,EAC1C3Q,EAAMsC,EAAMqO,GAAgB5M,EAAM4M,GAAgB,EAAI7B,EAEtD8B,EAvDR,SACEpE,EACA2C,EACAL,GAEA,IAAQxM,EAA0BkK,EAA1BlK,MAAOD,EAAmBmK,EAAnBnK,QAAS0B,EAAUyI,EAAVzI,MAElB4M,EAAexB,EAAU/C,QAAQ1E,iBAEvC,EAAwByH,EAAU/C,QAAQ5E,aAErC,CAAC,MAAO,UADR,CAAC,OAAQ,SADPqJ,EAAP,KAAcC,EAAd,KAIMC,EACJzO,EAAMuO,GACNvO,EAAMqO,GAAgB,EACtBtO,EAAQwO,GACR9M,EAAM4M,GAAgB,EACtB7B,EACIkC,EACJ1O,EAAMwO,GACNxO,EAAMqO,GAAgB,EACtBtO,EAAQyO,GACR/M,EAAM4M,GAAgB,EACtB7B,EAEF,OAAQiC,EAAU,GAAKA,EAAU,IAAMC,EAAU,GAAKA,EAAU,EACjE,CA4BwBC,CACrBzE,EACA2C,EACAL,GAGIoC,EAAc/B,EAAU/C,QAAQrL,KAChCoQ,EAAgBhC,EAAU/C,QAAQxE,gBAElCwJ,EAAiB7B,EACnBjN,EAAMqO,GAAgB,EAAIC,EAC1BvO,EAAQ8O,GAAiB9O,EAAQsO,GAAgB,EAAIrO,EAAM6O,GAE/D,YACK9C,IADL,MAEG6C,GAAc,OAFjB,EAGGC,GAAgBrR,EAAMsR,EAAgBrR,EAAKC,GAH9C,GAKD,CCuNiBqR,CACZrJ,KAAKwE,eAAed,MAAM,CAAEpJ,MAAOiL,IACnC4B,EACAnH,KAAKyG,OAAOK,aAyBd,MAAO,CACL/K,MAAAA,EACAzB,MAxB2B0F,KAAKyG,OAAOhN,kBAAZ,KAEpBiP,EAFoB,CAGvB5L,SAAU,QACVxB,IAAKiK,EAAYjK,IACjBC,KAAMgK,EAAYhK,OALK,KAQpBmN,EARoB,CASvB5L,SAAU,WACVxB,IACEiK,EAAYjK,IACZ0E,KAAKwE,eAAe8E,OAAOhO,IAC3BD,EAAcC,IACdM,EAAcN,IAChBC,KACEgK,EAAYhK,KACZyE,KAAKwE,eAAe8E,OAAO/N,KAC3BF,EAAcE,KACdK,EAAcL,OAOvB,EA1SH,EA4SUgO,kBAAA,SAAkBhE,GACxB,IAAMnM,EAAU4G,KAAKyG,OAAOhN,kBACxBuG,KAAKwE,eAAenK,QACpBkL,EAEEU,EAAmBzF,EAAcI,mBACrCZ,KAAKwE,eAAegF,0BAA0BpQ,GAAS,IAYzD,OATgBsH,OAAOkD,QACrBqC,EAAiBF,eAGiBjN,MAAK,Y,IAAEC,EAAAA,EAAAA,GAEzC,OAF+CpB,EAAAA,KAE9ByB,EADJiH,EAAUtH,GACO0G,SAC/B,IAGQ,OAGJwG,EAAiBH,oBAIf,KAHE,SAIV,EAvUH,EAyUSvN,OAAA,SAAO8C,EAA8BO,GAC1C,IAAM6N,EAAoBzJ,KAAKiI,wBACzBnD,EAAkB9E,KAAKmI,mBAAmBsB,GAC1ClE,EAAckE,EAAkB5E,eAAeC,GASrD,MAAO,CACL4E,OATa1J,KAAKyI,UAClBlD,EACAkE,EACApO,EACAO,GAMA+N,UAJgBF,EAAkBrF,QAAQrL,KAK1CoO,UAAWsC,EACXlE,YAAAA,EACAqE,eAAgB5J,KAAKuJ,kBAAkBhE,GAE1C,EA5VH,KChBasE,EAAb,WAQE,WACErF,EACiB/K,G,KAAAA,uBAAAA,E,KATHY,aAAAA,E,KACAC,WAAAA,E,KACAyB,WAAAA,E,KACAuN,YAAAA,E,KACA/R,YAAAA,E,KACA6C,sBAAAA,EAIG,KAAAX,kBAAAA,EAEjBiH,OAAOC,OAAOX,KAAMwE,EACrB,CAbH,EAeSvC,OAAP,SACE3J,EACAgC,EACAD,EACAiP,EACAvN,EACA3B,EACAX,EACAqQ,GAEA,IAAMvS,EAASwK,EAAOuB,WAAWhL,GAEjC,OAAO,IAAIuR,EACT,CACEvP,MAAOyH,EAAOG,YAAY5H,EAAO,CAC/BhC,YAAAA,EACA8J,eAAe,IAEjB/H,QAASyP,EACL/H,EAAOE,OAAON,EAAemI,MAC7B/H,EAAOG,YAAY7H,GACvB0B,MAAOA,EAAQgG,EAAOG,YAAYnG,GAASgG,EAAOsB,QAClDiG,OAAQA,EAASvH,EAAOG,YAAYoH,GAAU/R,EAC9CA,OAAAA,EACA6C,iBAAkB,CAChB7C,GADc,OAEX6C,EAAiB6G,KAAI,SAAAwE,GAAS,OAC/B1D,EAAOG,YAAYuD,EAAW,CAAEpD,gBAAgB,GADjB,MAKrC5I,EAEH,EAhDH,2BAkDEiK,MAAA,SAAMc,GACJ,OAAO,IAAIqF,EAAJ,KAEA7J,KACAwE,GAELxE,KAAKvG,kBAER,EA1DH,EAwEE+P,0BAAA,SAA0BpQ,EAAiB2Q,GAMzC,YANyCA,IAAAA,IAAAA,GAAgB,IAEvD/J,KAAKvG,oBAAsBsQ,EACvB,CAAC/J,KAAKzI,QACNyI,KAAK5F,kBAEa6G,KAAI,SAAA+I,GAAe,OACzCA,EAAgBlG,UAAU1K,EADe,GAG5C,EAjFH,+CA4DE,WACE,OAAO4G,KAAKwJ,0BAA0BxJ,KAAK1F,MAC5C,GA9DH,iCAgEE,WACE,OAAO0F,KAAK3F,QAAQuH,MAAQ5B,KAAK1F,MAAMsH,KACxC,GAlEH,kCAoEE,WACE,OAAO5B,KAAK3F,QAAQwH,OAAS7B,KAAK1F,MAAMuH,MACzC,KAtEH,KCoBIoI,EAAuC,K,IAgD9BC,EAWT,CACFhC,MAAM,EACNpB,YAAa,EACbC,gBAAiB,GACjBC,cAAe,EACfvN,mBAAmB,EACnB0N,UAAW,aACXO,mBCjG8C,CAC9C,eACA,aACA,gBACA,YACA,aACA,UACA,WACA,cACA,aACA,YACA,eACA,cACA,UDqFAJ,QAAS,QACTD,QAAS,SACTe,MAAM,EACN3C,eAAW0E,EACX9P,aAAS8P,G,SAGKC,EAAS,G,UACvBpM,OAAAA,OAAAA,IAAS,K,IACTvE,kBAAAA,OAAAA,IAAoB,EAAAyQ,EAAgBzQ,kBAAAA,E,IACpCnB,YAAAA,OAAAA,IAAc,EAAkB,oBAAXf,OAAyBA,YAAS4S,EAAAA,EACvC3Q,EAAAA,EAAhBG,e,IACAwN,UAAAA,OAAAA,IAAY,EAAA+C,EAAgB/C,UAAAA,E,IAC5BO,mBAAAA,OAAAA,IAAqB,EAAAwC,EAAgBxC,mBAAAA,E,IACrCJ,QAAAA,OAAAA,IAAU,EAAA4C,EAAgB5C,QAAAA,E,IAC1BD,QAAAA,OAAAA,IAAU,EAAA6C,EAAgB7C,QAAAA,E,IAC1Ba,KAAAA,OAAAA,IAAO,EAAAgC,EAAgBhC,KAAAA,E,IACvBE,KAAAA,OAAAA,IAAO,EAAA8B,EAAgB9B,KAAAA,E,IACvBpB,cAAAA,OAAAA,IAAgB,EAAAkD,EAAgBlD,cAAAA,E,IAChCD,gBAAAA,OAAAA,IAAkB,EAAAmD,EAAgBnD,gBAAAA,E,IAClCD,YAAAA,OAAAA,IAAc,EAAAoD,EAAgBpD,YAAAA,E,IAC9BrB,UAAAA,OAAAA,IAAY,EAAAyE,EAAgBzE,UAAAA,E,IAC5BlB,gBAAAA,OAAAA,IAAkB,SAClB8F,EAAAA,EAAAA,YACApM,EAAAA,EAAAA,eACAC,EAAAA,EAAAA,cACSxE,EAAAA,EAATW,QAGA,GAA0BiQ,EAAAA,EAAAA,WAAgB,iBAAO,CAC/CX,UACgB,WAAdxC,EACI,SACAZ,EAAWG,0BAA0BS,GAAW,GAAGpO,KACzD2Q,OAAQ,CACNpP,MAAO,CACLwC,SAAUrD,EAAoB,QAAU,WACxC6B,IAAK,EACLC,KAAM,GAERQ,MAAO,CACLe,SAAU,WACVxB,IAAK,EACLC,KAAM,IAd8B,IAAnCxB,EAAP,KAAcwQ,EAAd,KAmBMC,GAAmBrT,EAAAA,EAAAA,QAAoB,MAIvCsT,E,SXpCNC,EACApR,GAEA,IAAMmR,GAAYtT,EAAAA,EAAAA,QAAiBuT,GAEnC,OAAKpR,GAKLmR,EAAUpT,QAAUqT,EACbD,IALLA,EAAUpT,QAAU,KACboT,EAKV,CWwBmBE,CAAa5Q,EAAOiE,GAGhC4M,GAAqBzT,EAAAA,EAAAA,QAAO,CAAE0T,WAAW,KAC/CpT,EAAAA,EAAAA,YAAU,WACR,OAAO,WAELmT,EAAmBvT,QAAQwT,WAAY,CACxC,CACF,GAAE,IAKH,IAAMC,GAAoB5P,EAAAA,EAAAA,cACxB,WAEEG,EACAO,G,IAFEG,EAAAA,EAAAA,MAAOzB,EAAAA,EAAAA,MAAOF,EAAAA,EAAAA,iBAAkBC,EAAAA,EAAAA,QAI5BiP,EAASlP,EAAiB,GAE1BoK,EAAiBqF,EAAe5H,OACpC3J,EACAgC,EACAD,EACAiP,EACAvN,EACA3B,EACAX,EAPqB,MAQrBC,OARqB,EAQrBA,EAAeqR,WAGXtE,EAAyB,CAC7BU,UAAAA,EACAO,mBAAAA,EACAQ,KAAAA,EACA3D,gBAAAA,EACAuC,YAAAA,EACAC,gBAAAA,EACAC,cAAAA,EACAM,QAAAA,EACAD,QAAAA,EACAe,KAAAA,EACA3O,kBAAAA,GAGF,EAA8C8M,EAAWtE,OACvDuC,EACAiC,GACAlO,OAAO8C,EAAeO,GAHhBgO,EAAR,EAAQA,eAKFoB,EAAkB,CACtBrB,UANF,EAAwBA,UAOtBD,OAPF,EAAmCA,QAUnC,IAAKe,EAAUpT,SAiGrB,SAAwBoF,EAAiBC,GACvC,GAAID,EAASkN,YAAcjN,EAAKiN,UAC9B,OAAO,EAUT,IAPA,IAOA,MAP+C,CAC7C,WACA,MACA,OACA,QACA,UAEF,eAA+B,CAA1B,IAAM5Q,EAAI,KACb,GACE0D,EAASiN,OAAOpP,MAAMvB,KAAU2D,EAAKgN,OAAOpP,MAAMvB,IAClD0D,EAASiN,OAAO3N,MAAMhD,KAAU2D,EAAKgN,OAAO3N,MAAMhD,GAElD,OAAO,CAEV,CAED,OAAO,CACR,CAvH+BkS,CAAeR,EAAUpT,QAAS2T,GAAW,CACrEP,EAAUpT,QAAU2T,EAOpBJ,EAAmBvT,QAAQwT,WAAY,EACvC,IAAMK,EAAQ,CAAEL,WAAW,GAC3BD,EAAmBvT,QAAU6T,EAE7BC,QAAQC,UAAUC,MAAK,WAChBH,EAAML,WACTN,EAASS,EAEZ,GACF,CAEG/S,EAAM2R,IAAmB3R,EAAMoS,IACjCA,EAAYT,EAEf,GACD,CACE9C,EACAoB,EACAnB,EACAzO,EACAiM,EACA8F,EACA5Q,EACA0N,EACAO,EACAJ,EACAD,EACAe,EACApB,EACAyD,EACA/Q,IAIJ,GACEL,EAAiB,CACfG,uBAAAA,EACAlB,YAAAA,EACAgB,QAAS0E,EACTvE,kBAAAA,EACAF,SAAUuR,EACVpR,cAAAA,IAPIsD,GAAR,GAAQA,WAAYL,GAApB,GAAoBA,SAAU1C,GAA9B,GAA8BA,SAAUkB,GAAxC,GAAwCA,uBAUxC,GAAmD4C,EAAS,CAC1DC,OAAAA,EACAC,eAAAA,EACAC,cAAAA,IAHMe,GAAR,GAAQA,wBAAyBzB,GAAjC,GAAiCA,cAM3B8N,GAAuB,CAC3BC,aAAcpR,QAAQT,GACjB,CAAC,EACF,CACEtB,IAAKF,EACH8E,GACAiC,GAAwB5E,QACxBmQ,IAGRgB,WAAY,CACVpT,IAAKF,EAAUyE,GAAUsC,GAAwB3E,OACjDyC,MAAOhD,EAAM2P,OAAOpP,OAEtBmR,WAAY,CACVrT,IAAK6B,GACL8C,MAAOhD,EAAM2P,OAAO3N,MACpB4N,UAAW5P,EAAM4P,WAEnBA,UAAW5P,EAAM4P,UACjB+B,cAAe1N,EACXtE,EACEA,EAAcqR,YADH,SAEXP,EAAiBnT,cAFN,EAEX,EAA0BiL,wBAC5B,KACJqJ,YAAa,SAAApO,GAAQ,MACC,oBAAb/E,UACHoT,EAAAA,EAAAA,eACE/N,EAAAA,EAAAA,eAAcP,EAAe,CAAEE,cAAAA,GAAeD,SAAAA,IAC9C9D,IAAsB0B,GAoClC,SAA6BsK,GAC3B,IAAIrO,EAEJ,GAAyB,mBAAdqO,GAET,MADArO,EAAUqO,MACQrO,aAAmByU,aACnC,MAAM,IAAIzQ,MAAJ,2GAIH,GAAIqK,aAAqBoG,YAC9BzU,EAAUqO,OACL,GAAyB,iBAAdA,GAEhB,KADArO,EAAUoB,SAASsT,eAAerG,IAEhC,MAAM,IAAIrK,MAAJ,8CAC0CqK,EAD1C,uEAIH,IAAIwE,aAA4B4B,YACrC,OAAO5B,GAEP7S,EAAUoB,SAASsT,eAAeC,OAEhC3U,EAAUoB,SAASqF,cAAc,QACzBmO,GAAKD,EACb3U,EAAQ2F,MAAMkP,QAAd,oGAMAzT,SAASC,KAAKyT,YAAY9U,GAE7B,CAED,OAAOA,CACR,CAxEe+U,CAAoB1G,GACpBtK,IAEN,IARe,GAWvB,OAAOmQ,EACR,CA0BD,IAAMS,EAAuB,S,qGEpUvBK,EAAO,OACPC,EAAM,MACNC,EAAS,SACTC,EAAQ,QAEd,SAASC,EAAqBC,EAAeC,GAC3C,OAAOvL,KAAKwL,IAAIF,GAAStL,KAAKyL,GAAK,MAAQF,CAC5C,CAED,SAASG,EACPC,EACAC,EACA7M,EACA8M,G,MASA,QAPS,MACNV,GADM,MACSU,EADT,IACwBD,EADxB,IACiCD,EADjC,EAENT,GAFM,OAEOU,EAFP,KAEgBD,EAAQE,GAFxB,EAGNT,IAAYS,EAHN,MAGuBF,EAHvB,IAGgCC,EAHhC,EAINX,GAJM,QAIQU,EAAQE,GAJhB,IAI+BD,EAJ/B,GAOE7M,EAAKnH,KACjB,CAED,SAASkU,EACPH,EACAC,EACA7M,EACAgN,EACAT,G,UAEMU,EAAqBD,EAAY,GAAMJ,EAAQ,EAE/CM,GAAI,OACPd,GAAS,CAAC,EAAGQ,GADN,EAEPT,GAAM,CAAC,EAAG,GAFH,EAGPE,GAAQ,CAACO,EAAOC,GAHT,EAIPX,GAAO,CAAC,EAAGW,GAJJ,GAKR7M,EAAKnH,MAAMsU,KAAK,KAEZC,EAAIpN,EAAKV,aAAL,WAAiCuN,EAErCQ,EAASR,EAAQ,EACjBS,EAAMT,EAAQ,EAAIP,EAAqBC,EAAOK,EAAQ,GACtDW,EAAMX,EAAQ,EAEdY,GAAI,OACPpB,GAAS,CAAC,IAAKkB,EAAKC,EAAKF,EAASJ,EAAmB,EAAGI,EAAQ,GADzD,EAEPlB,GAAM,CACL,IACAmB,EACAV,EAAQW,EACRF,EAASJ,EACTL,EACAS,EACAT,GATM,EAWPP,GAAQ,CAAC,IAAKkB,EAAKV,EAAQS,EAAK,EAAGD,EAASJ,EAAmB,EAAGI,GAX3D,EAYPnB,GAAO,CACN,IACAU,EAAQW,EACRV,EAAQS,EACRV,EACAS,EAASJ,EACTL,EACAS,GAnBM,GAqBRrN,EAAKnH,MAAMsU,KAAK,KAEZM,EAAMZ,EAAQ,EAAIP,EAAqBC,EAAOK,EAAQ,GACtDc,EAAMd,EAAQ,EAgBpB,MAAO,CAAC,IAAKM,EAAGE,EAAGI,GAdT,OACPpB,GAAS,CAAC,IAAKiB,EAASJ,EAAmB,EAAGQ,EAAKC,EAAKR,GADjD,EAEPf,GAAM,CAAC,IAAKkB,EAASJ,EAAmBL,EAAOa,EAAKb,EAAQc,EAAKR,GAF1D,EAGPb,GAAQ,CAAC,IAAK,EAAGgB,EAASJ,EAAmBS,EAAKb,EAAQY,EAAKP,GAHxD,EAIPhB,GAAO,CACN,IACAU,EACAS,EAASJ,EACTL,EAAQc,EACRb,EAAQY,EACRP,GAVM,GAYRlN,EAAKnH,MAAMsU,KAAK,MAEOA,KAAK,IAC/B,CAED,SAASQ,EACPf,EACAC,EACAC,EACA9M,EACAuM,GAEA,IAAMqB,EAAetB,EAAqBC,EAAOO,GAEjD,EAAgB9M,EAAKJ,OAAwC,CAAC,EAAGkN,GAAnC,CAACF,EAAOA,EAAQE,GAAvCI,EAAP,KAAUE,EAAV,KAEA,OAAIpN,EAAKV,aACA,CACL,IACA4N,EACAJ,EACA,IACAD,EAAQC,EACR,IACAM,EACAP,EAAQC,EAAcc,EACtB,IACAA,EAAed,EACf,KACAK,KAAK,KAGF,CACL,IACAL,EACAI,EACA,IACAL,EAAQC,EACR,IACAD,EAAQC,EAAcc,EACtBR,EACA,IACAQ,EAAed,EACf,KACAK,KAAK,IACR,C,ICxGIU,EDiJQC,GAAQC,EAAAA,EAAAA,aAAsC,WAYzD7V,G,QAVEsU,KAAAA,OAAAA,IAAO,M,IACPD,MAAAA,OAAAA,IAAQ,O,IACRO,YAAAA,OAAAA,IAAc,M,IACdkB,YAAAA,OAAAA,IAAc,Y,IACdhB,UAAAA,OAAAA,IAAY,M,IACZiB,gBAAAA,OAAAA,IAAkB,Y,IAClBxE,UAAAA,OAAAA,IAAY,U,IACZ5M,MAAAA,OAAAA,IAAQ,GAAC,EAAD,EACLgE,E,oIAAAA,CAAAA,EAAAA,GAIL,GAAkB,WAAd4I,EACF,OAAO,KAGT,IAAMzJ,EAAOG,EAAUsJ,GACjBmD,EAAQJ,EACRK,EAA4C,EAApCP,EAAqBC,EAAOC,GAEpC0B,EAAUjN,KAAKnJ,IAAI8U,EAAOC,GAEhC,OAAOlP,EAAAA,EAAAA,eACL,MADkB,GAGhBzF,IAAAA,GACG2I,EAJa,CAKhBhE,MAAO,EAAF,GACAA,EADA,CAEHsR,UAAW,aAAYnO,EAAKV,aAAe,IAAM,KAAxC,WAEXoC,MAAOwM,EACPvM,OAAQuM,EACRE,oBAAqBpO,EAAKJ,OAAS,WAAa,WAChDyO,QAAS1B,EAAWC,EAAOC,EAAO7M,EAAM8M,MAE1CnP,EAAAA,EAAAA,eAAc,OAAQ,CACpB2Q,KAAML,EACNM,YAAazB,EACb0B,OAAQR,EACRS,EAAG1B,EAAgBH,EAAOC,EAAO7M,EAAMgN,EAAWT,MAEpD5O,EAAAA,EAAAA,eAAc,OAAQ,CACpB2Q,KAAML,EACNQ,EAAGd,EAAkBf,EAAOC,EAAOC,EAAa9M,EAAMuM,KAG3D,KClMD,SAAKsB,GACHA,EAAAA,EAAAA,SAAAA,GAAA,WACAA,EAAAA,EAAAA,QAAAA,GAAA,UACAA,EAAAA,EAAAA,KAAAA,GAAA,MAHF,EAAKA,IAAAA,EAAM,I,wFC3BX,SAASa,IACL,IAAIC,GAAY,IAAA1X,SAAO,GAOvB,OANA,QAA0B,WAEtB,OADA0X,EAAUxX,SAAU,EACb,WACHwX,EAAUxX,SAAU,CACxB,CACJ,GAAG,IACIwX,CACX,C,kCCLIC,EAAgB,SAAUC,GAC1B,IAAIxR,EAAWwR,EAAGxR,SAAUyR,EAAUD,EAAGC,QAASC,EAAYF,EAAGE,UAAWC,EAAiBH,EAAGG,eAAgBC,EAASJ,EAAGI,OAAQC,EAAwBL,EAAGK,sBAC3JC,GAAmB,OAAYC,GAC/BtD,GAAK,SACLuD,GAAU,IAAAhV,UAAQ,WAAc,MAAO,CACvCyR,GAAIA,EACJgD,QAASA,EACTC,UAAWA,EACXE,OAAQA,EACRD,eAAgB,SAAUM,GACtB,IAAIC,EAAKV,EACTM,EAAiB3U,IAAI8U,GAAS,GAC9B,IACI,IAAK,IAAIE,GAAK,QAASL,EAAiBnL,UAAWyL,EAAKD,EAAGhT,QAASiT,EAAGC,KAAMD,EAAKD,EAAGhT,OAAQ,CAEzF,IADiBiT,EAAGhY,MAEhB,MACR,CACJ,CACA,MAAOkY,GAASJ,EAAM,CAAEK,MAAOD,EAAS,CACxC,QACI,IACQF,IAAOA,EAAGC,OAASb,EAAKW,EAAGK,SAAShB,EAAGiB,KAAKN,EACpD,CACA,QAAU,GAAID,EAAK,MAAMA,EAAIK,KAAO,CACxC,CACAZ,SAAgEA,GACpE,EACAe,SAAU,SAAUT,GAEhB,OADAH,EAAiB3U,IAAI8U,GAAS,GACvB,WAAc,OAAOH,EAAiBzR,OAAO4R,EAAU,CAClE,EACA,GAMJJ,OAAwBjF,EAAY,CAAC8E,IAWrC,OAVA,IAAA1U,UAAQ,WACJ8U,EAAiBvQ,SAAQ,SAAUoR,EAAGC,GAAO,OAAOd,EAAiB3U,IAAIyV,GAAK,EAAQ,GAC1F,GAAG,CAAClB,IAKJ,aAAgB,YACXA,IAAcI,EAAiB3C,OAASwC,SAAgEA,IAC7G,GAAG,CAACD,IACI,gBAAoBmB,EAAA,EAAgBtS,SAAU,CAAEnG,MAAO4X,GAAWhS,EAC9E,EACA,SAAS+R,IACL,OAAO,IAAIe,GACf,C,wBCjDIC,EAAc,SAAUvM,GAAS,OAAOA,EAAMoM,KAAO,EAAI,EAiD7D,IAAII,EAAkB,SAAUxB,GAC5B,IAAIxR,EAAWwR,EAAGxR,SAAU4R,EAASJ,EAAGI,OAAQO,EAAKX,EAAGC,QAASA,OAAiB,IAAPU,GAAuBA,EAAIR,EAAiBH,EAAGG,eAAgBsB,EAAkBzB,EAAGyB,gBAAiBb,EAAKZ,EAAGK,sBAAuBA,OAA+B,IAAPO,GAAuBA,EAG1Pc,GAAK,QC3Db,WACI,IAAI5B,EAAYD,IACZG,GAAK,SAAO,IAAAzE,UAAS,GAAI,GAAIoG,EAAoB3B,EAAG,GAAI4B,EAAuB5B,EAAG,GAClF6B,GAAc,IAAA1V,cAAY,WAC1B2T,EAAUxX,SAAWsZ,EAAqBD,EAAoB,EAClE,GAAG,CAACA,IAMJ,MAAO,EADmB,IAAAxV,cAAY,WAAc,OAAO,KAAK2V,WAAWD,EAAc,GAAG,CAACA,IAChEF,EACjC,CD+CoBI,GAAkB,GAAIF,EAAcH,EAAG,GACnDM,GAAyB,IAAA1S,YAAW2S,EAAA,GAAoBJ,YACxDG,IACAH,EAAcG,GAClB,IAAIlC,EAAYD,IAEZqC,EApDR,SAAsB1T,GAClB,IAAI2T,EAAW,GAMf,OAJA,EAAAC,SAASrS,QAAQvB,GAAU,SAAUwG,IAC7B,IAAAqN,gBAAerN,IACfmN,EAASjY,KAAK8K,EACtB,IACOmN,CACX,CA4C2BG,CAAa9T,GAChC+T,EAAmBL,EACnBM,EAAU,IAAIpT,IAGdqT,GAAkB,IAAAra,QAAOma,GAEzBG,GAAc,IAAAta,QAAO,IAAIkZ,KAAOhZ,QAGhCqa,GAAkB,IAAAva,SAAO,GAW7B,IAVA,QAA0B,WACtBua,EAAgBra,SAAU,EAtElC,SAA2BkG,EAAUkU,GACjClU,EAASuB,SAAQ,SAAUiF,GACvB,IAAIoM,EAAMG,EAAYvM,GACtB0N,EAAY/W,IAAIyV,EAAKpM,EACzB,GACJ,CAkEQ4N,CAAkBV,EAAkBQ,GACpCD,EAAgBna,QAAUia,CAC9B,KACA,QAAiB,WACbI,EAAgBra,SAAU,EAC1Boa,EAAYG,QACZL,EAAQK,OACZ,IACIF,EAAgBra,QAChB,OAAQ,gBAAoB,WAAgB,KAAMia,EAAiBrQ,KAAI,SAAU8C,GAAS,OAAQ,gBAAoB+K,EAAe,CAAEqB,IAAKG,EAAYvM,GAAQkL,WAAW,EAAMD,UAASA,QAAU7E,EAAmBiF,sBAAuBA,GAAyBrL,EAAS,KAGpRuN,GAAmB,QAAc,IAAI,QAAOA,IAAmB,GAO/D,IAJA,IAAIO,EAAcL,EAAgBna,QAAQ4J,IAAIqP,GAC1CwB,EAAab,EAAiBhQ,IAAIqP,GAElCyB,EAAaF,EAAYjX,OACpBoX,EAAI,EAAGA,EAAID,EAAYC,IAAK,CACjC,IAAI7B,EAAM0B,EAAYG,IACW,IAA7BF,EAAWxJ,QAAQ6H,IACnBoB,EAAQ5T,IAAIwS,EAEpB,CA4CA,OAzCIK,GAAmBe,EAAQ7E,OAC3B4E,EAAmB,IAIvBC,EAAQzS,SAAQ,SAAUqR,GAEtB,IAAiC,IAA7B2B,EAAWxJ,QAAQ6H,GAAvB,CAEA,IAAIpM,EAAQ0N,EAAYhX,IAAI0V,GAC5B,GAAKpM,EAAL,CAEA,IAAIkO,EAAiBJ,EAAYvJ,QAAQ6H,GAgBzCmB,EAAiBY,OAAOD,EAAgB,EAAG,gBAAoBnD,EAAe,CAAEqB,IAAKG,EAAYvM,GAAQkL,WAAW,EAAOC,eAf9G,WACTuC,EAAY7T,OAAOuS,GACnBoB,EAAQ3T,OAAOuS,GAEf,IAAIgC,EAAcX,EAAgBna,QAAQ+a,WAAU,SAAUC,GAAgB,OAAOA,EAAalC,MAAQA,CAAK,IAG/G,GAFAqB,EAAgBna,QAAQ6a,OAAOC,EAAa,IAEvCZ,EAAQ7E,KAAM,CAEf,GADA8E,EAAgBna,QAAU4Z,GACA,IAAtBpC,EAAUxX,QACV,OACJuZ,IACA1B,GAAkBA,GACtB,CACJ,EACmJC,OAAQA,EAAQC,sBAAuBA,GAAyBrL,GAjBzM,CAHA,CAqBd,IAGAuN,EAAmBA,EAAiBrQ,KAAI,SAAU8C,GAC9C,IAAIoM,EAAMpM,EAAMoM,IAChB,OAAOoB,EAAQe,IAAInC,GAAO,EAAW,gBAAoBrB,EAAe,CAAEqB,IAAKG,EAAYvM,GAAQkL,WAAW,EAAMG,sBAAuBA,GAAyBrL,EACxK,IACY,eAAR,KACAyM,GACAc,EAAiB1W,OAAS,GAC1B2X,QAAQC,KAAK,+JAET,gBAAoB,WAAgB,KAAMjB,EAAQ7E,KACpD4E,EACAA,EAAiBrQ,KAAI,SAAU8C,GAAS,OAAO,IAAA0O,cAAa1O,EAAQ,IAC9E,C","sources":["webpack://dockview-docs/../../node_modules/react-laag/src/hooks.ts","webpack://dockview-docs/../../node_modules/react-laag/src/util.ts","webpack://dockview-docs/../../node_modules/react-laag/src/useTrackElements.ts","webpack://dockview-docs/../../node_modules/react-laag/src/useGroup.ts","webpack://dockview-docs/../../node_modules/react-laag/src/Sides.ts","webpack://dockview-docs/../../node_modules/react-laag/src/BoundsOffsets.ts","webpack://dockview-docs/../../node_modules/react-laag/src/Bounds.ts","webpack://dockview-docs/../../node_modules/react-laag/src/Placement.ts","webpack://dockview-docs/../../node_modules/react-laag/src/getArrowStyle.ts","webpack://dockview-docs/../../node_modules/react-laag/src/Placements.ts","webpack://dockview-docs/../../node_modules/react-laag/src/SubjectsBounds.ts","webpack://dockview-docs/../../node_modules/react-laag/src/useLayer.ts","webpack://dockview-docs/../../node_modules/react-laag/src/PlacementType.ts","webpack://dockview-docs/../../node_modules/react-laag/src/Arrow.ts","webpack://dockview-docs/../../node_modules/react-laag/src/useHover.ts","webpack://dockview-docs/../../node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs","webpack://dockview-docs/../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","webpack://dockview-docs/../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","webpack://dockview-docs/../../node_modules/framer-motion/dist/es/utils/use-force-update.mjs"],"sourcesContent":["import {\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  MutableRefObject,\n  useState,\n  MouseEvent\n} from \"react\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility hook to track the reference of a html-element.\n * It notifies the listener when a change occured, so it can act\n * on the change\n */\nexport function useTrackRef(\n  onRefChange: (element: HTMLElement) => void\n): (node: HTMLElement | null) => void {\n  const storedReference = useRef<HTMLElement | null>(null);\n\n  // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n  function setter(element: HTMLElement | null) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n\n/**\n * Utility hook that stores mutable state.\n * Since a getter function is used, it will always return the most\n * up-to-date state. This is useful when you want to get certain state within\n * an effect, without triggering the same effect when the same state changes.\n * Note: may be seen as an anti-pattern.\n */\nexport function useMutableStore<State>(initialState: State): readonly [\n  () => State,\n  {\n    (setter: (state: State) => State): void;\n    (setter: State): void;\n  }\n] {\n  const state = useRef<State>(initialState);\n\n  return useMemo(() => {\n    function set(setter: (state: State) => State): void;\n    function set(setter: State): void;\n    function set(setter: any): void {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set] as const;\n  }, []);\n}\n\n/**\n * Utility hook that keeps track of active event listeners and how\n * to remove these listeners\n */\nexport function useEventSubscriptions() {\n  const subscriptions = useRef<Array<() => void>>([]);\n\n  return useMemo(() => {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (const unsubscribe of subscriptions.current!) {\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber: () => void) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions,\n      removeAllEventSubscriptions,\n      addEventSubscription\n    };\n  }, []);\n}\n\n/**\n * SSR-safe effect hook\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Utility hook that tracks an state object.\n * If `enabled=false` it will discard changes and reset the lastState to `null`\n */\nexport function useLastState<T extends unknown>(\n  currentState: T,\n  enabled: boolean\n): MutableRefObject<T | null> {\n  const lastState = useRef<T | null>(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nexport type UseMousePositionAsTriggerOptions = {\n  /**\n   * @description Should the position be actively tracked?\n   * @default true\n   */\n  enabled?: boolean;\n  /**\n   * @description Should `handleMouseEvent` preventDefault()?\n   * @default true\n   */\n  preventDefault?: boolean;\n};\n\nexport type UseMousePositionAsTriggerProps = {\n  hasMousePosition: boolean;\n  resetMousePosition: () => void;\n  handleMouseEvent: (evt: MouseEvent) => void;\n  trigger: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n  parentRef: MutableRefObject<any>;\n};\n\nconst EMPTY_BOUNDS: IBounds = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n\n/**\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\n * This is useful in scenario's like context-menu's.\n *\n * @example\n * ```tsx\n * const {\n *  hasMousePosition,\n *  resetMousePosition,\n *  handleMouseEvent,\n *  trigger\n *  } = useMousePositionAsTrigger();\n *\n * const { renderLayer, layerProps } = useLayer({\n *  isOpen: hasMousePosition,\n *  trigger,\n *  onOutsideClick: resetMousePosition\n * });\n *\n * return (\n *  <>\n *   {isOpen && renderLayer(<div {...layerProps} />)}\n *   <div onContextMenu={handleMouseEvent} />\n *  </>\n * );\n * ```\n */\nexport function useMousePositionAsTrigger({\n  enabled = true,\n  preventDefault = true\n}: UseMousePositionAsTriggerOptions = {}): UseMousePositionAsTriggerProps {\n  const parentRef = useRef<any>(null);\n\n  const [mouseBounds, setMouseBounds] = useState<IBounds>(EMPTY_BOUNDS);\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  const hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt: MouseEvent) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n    const { clientX: left, clientY: top } = evt;\n    setMouseBounds({\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition,\n    resetMousePosition,\n    handleMouseEvent,\n    trigger: {\n      getBounds: () => mouseBounds!,\n      getParent: parentRef.current ? () => parentRef.current : undefined\n    },\n    parentRef\n  };\n}\n","/**\n * Convert a pixel value into a numeric value\n * @param value string value (ie. '12px')\n */\nexport function getPixelValue(value: string) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n\n/**\n * Returns a numeric value that doesn't exceed min or max\n */\nexport function limit(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Utility function which ensures whether a value is truthy\n */\nexport function isSet<T>(value: T | null | undefined): value is T {\n  return value === null || value === undefined ? false : true;\n}\n\n/**\n * Utility function that let's you assign multiple references to a 'ref' prop\n * @param refs list of MutableRefObject's and / or callbacks\n */\nexport function mergeRefs(...refs: any[]) {\n  return (element: HTMLElement | null) => {\n    for (const ref of refs) {\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element!;\n      }\n    }\n  };\n}\n","import { useCallback, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\nimport { ResizeObserverClass, ScrollOffsets, BorderOffsets } from \"./types\";\nimport {\n  useTrackRef,\n  useMutableStore,\n  useEventSubscriptions,\n  useIsomorphicLayoutEffect\n} from \"./hooks\";\nimport { getPixelValue } from \"./util\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility to get the correct ResizeObserver class\n */\nexport function getResizeObserver(\n  environment: Window | undefined,\n  polyfill: ResizeObserverClass | undefined\n): ResizeObserverClass | undefined {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || (environment as any).ResizeObserver;\n}\n\n/**\n * Utility function that given a element traverses up in the html-hierarchy\n * to find and return all ancestors that have scroll behavior\n */\nexport function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } =\n    environment.getComputedStyle(element);\n\n  if (\n    [overflow, overflowX, overflowY].some(prop =>\n      [\"auto\", \"scroll\"].includes(prop)\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n\nfunction createReferenceError(subject: string) {\n  return `react-laag: Could not find a valid reference for the ${subject} element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the ${subject} element when isOpen: true. Also make sure your component forwards the ref with \"forwardRef()\".\n   - Make sure that you are actually rendering the ${subject} when the isOpen prop is set to true`;\n}\n\nexport type OnChangeElements = {\n  layer: HTMLElement;\n  trigger: HTMLElement;\n  arrow: HTMLElement | null;\n  scrollContainers: HTMLElement[];\n};\n\nexport type UseTrackElementsProps = {\n  enabled: boolean;\n  onChange: (\n    elements: OnChangeElements,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ) => void;\n  environment: Window | undefined;\n  ResizeObserverPolyfill: ResizeObserverClass | undefined;\n  overflowContainer: boolean;\n  triggerOption?: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n};\n\ntype UseTrackElementsReturnValue = {\n  triggerRef: (element: HTMLElement | null) => void;\n  layerRef: (element: HTMLElement | null) => void;\n  arrowRef: React.MutableRefObject<HTMLElement | null>;\n  closestScrollContainer: HTMLElement | null;\n};\n\n/**\n * This hook has the responsibility to track the bounds of:\n * - the trigger element\n * - the layer element\n * - the arrow element\n * - the scroll-containers of which the trigger element is a descendant of\n *\n * It will call the `onChange` callback with a collection of these elements when any\n * of the tracked elements bounds have changed\n *\n * It will detect these changes by listening:\n * - when the reference of the trigger element changes\n * - when the reference of the layer element changes\n * - when the trigger, layer or document body changes in size\n * - when the user scrolls the page, or any of the scroll containers\n */\nexport function useTrackElements({\n  // should we track the bounds?\n  enabled,\n  // call this callback when the bounds have changed\n  onChange,\n  // optional environment (i.e. when using iframes)\n  environment,\n  // optionally inject a polyfill when the browser does not support it\n  // out of the box\n  ResizeObserverPolyfill,\n  // behavior will alter slightly when `overflowContainer` is enabled\n  overflowContainer,\n  // the optional trigger-option provided by the user\n  triggerOption\n}: UseTrackElementsProps): UseTrackElementsReturnValue {\n  // get the correct reference to the ResizeObserver class\n  const ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);\n\n  // warn the user when no valid ResizeObserver class could be found\n  useEffect(() => {\n    warning(\n      ResizeObserver,\n      `This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://github.com/everweij/react-laag#resize-observer`\n    );\n  }, [ResizeObserver]);\n\n  // keep reference of the optional arrow-component\n  const arrowRef = useRef<HTMLElement | null>(null);\n\n  // if user has provided the trigger-option we should ingore certain things elsewhere\n  const hasTriggerOption = Boolean(triggerOption);\n\n  // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n  const [get, set] = useMutableStore<{\n    scrollContainers: HTMLElement[];\n    trigger: HTMLElement | null;\n    layer: HTMLElement | null;\n  }>({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  });\n\n  // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n  const {\n    hasEventSubscriptions,\n    addEventSubscription,\n    removeAllEventSubscriptions\n  } = useEventSubscriptions();\n\n  // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n  const handleChange = useCallback(\n    function handleChange() {\n      const { layer, trigger, scrollContainers } = get();\n      const closestScrollContainer = scrollContainers[0];\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      // ignore when user has provided the trigger-option\n      if (!trigger && !hasTriggerOption) {\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      let scrollOffsets: ScrollOffsets = { top: 0, left: 0 };\n      if (closestScrollContainer) {\n        const { scrollLeft, scrollTop } = closestScrollContainer;\n        scrollOffsets = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n      } else {\n        const { scrollX, scrollY } = environment!;\n        scrollOffsets = {\n          top: scrollY,\n          left: scrollX\n        };\n      }\n\n      let borderOffsets: BorderOffsets = { left: 0, top: 0 };\n      if (closestScrollContainer) {\n        const { borderLeftWidth, borderTopWidth } =\n          environment!.getComputedStyle(closestScrollContainer);\n\n        borderOffsets = {\n          left: getPixelValue(borderLeftWidth) || 0,\n          top: getPixelValue(borderTopWidth) || 0\n        };\n      }\n\n      onChange(\n        {\n          layer,\n          trigger: trigger!,\n          scrollContainers,\n          arrow: arrowRef.current\n        },\n        scrollOffsets,\n        borderOffsets\n      );\n    },\n    [get, onChange, environment, arrowRef, hasTriggerOption]\n  );\n\n  // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n  const addEventListeners = useCallback(\n    function addEventListeners() {\n      const { trigger, layer, scrollContainers } = get();\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      if (!trigger && !hasTriggerOption) {\n        // ignore when user has provided the trigger-option\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      if (ResizeObserver) {\n        let ignoredInitialCall = false;\n        const observerCallback = () => {\n          if (!ignoredInitialCall) {\n            ignoredInitialCall = true;\n            return;\n          }\n\n          handleChange();\n        };\n\n        const observer = new ResizeObserver(observerCallback);\n        for (const element of [trigger, layer, document.body]) {\n          if (element) observer.observe(element);\n        }\n\n        addEventSubscription(() => {\n          for (const element of [trigger, layer, document.body]) {\n            if (element) observer.unobserve(element);\n          }\n          observer.disconnect();\n        });\n      }\n\n      const listenForScrollElements = [environment!, ...scrollContainers];\n      for (const element of listenForScrollElements) {\n        element.addEventListener(\"scroll\", handleChange);\n\n        addEventSubscription(() =>\n          element.removeEventListener(\"scroll\", handleChange)\n        );\n      }\n    },\n    [\n      get,\n      addEventSubscription,\n      handleChange,\n      environment,\n      ResizeObserver,\n      hasTriggerOption\n    ]\n  );\n\n  // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n  const resetWhenReferenceChangedWhileTracking = useCallback(\n    (previous: HTMLElement | null, next: HTMLElement) => {\n      if (enabled && previous && previous !== next) {\n        removeAllEventSubscriptions();\n        addEventListeners();\n        handleChange();\n      }\n    },\n    [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]\n  );\n\n  // Logic when reference to layer changes\n  const layerRef = useTrackRef(\n    useCallback(\n      layer => {\n        const { layer: previousLayer } = get();\n\n        // store new reference\n        set(state => ({\n          ...state,\n          layer\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking]\n    )\n  );\n\n  const getScrollContainers = useCallback(\n    function handleScrollContainers(element: HTMLElement) {\n      const scrollContainers = findScrollContainers(element, environment);\n\n      const closestScrollContainer = scrollContainers[0];\n\n      if (closestScrollContainer) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const position = environment!.getComputedStyle(\n          closestScrollContainer\n        ).position;\n\n        const closestScrollContainerHasCorrectStyling =\n          [\"relative\", \"absolute\", \"fixed\"].includes(position) ||\n          overflowContainer;\n\n        if (!closestScrollContainerHasCorrectStyling) {\n          closestScrollContainer.style.position = \"relative\";\n        }\n\n        warning(\n          closestScrollContainerHasCorrectStyling,\n          `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \"${position}\". For now, \"position: relative;\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.`\n        );\n      }\n      return scrollContainers;\n    },\n    [environment, overflowContainer]\n  );\n\n  // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n  const triggerRef = useTrackRef(\n    useCallback(\n      trigger => {\n        // collect list of scroll containers\n        const scrollContainers = getScrollContainers(trigger);\n\n        const { trigger: previousTrigger } = get();\n\n        // store new references\n        set(state => ({\n          ...state,\n          trigger,\n          scrollContainers\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]\n    )\n  );\n\n  // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n  const triggerOptionParent = triggerOption?.getParent?.();\n  useIsomorphicLayoutEffect(() => {\n    if (!triggerOptionParent) {\n      return;\n    }\n    set(state => ({\n      ...state,\n      scrollContainers: getScrollContainers(triggerOptionParent)\n    }));\n  }, [triggerOptionParent, set, getScrollContainers]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return () => {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [\n    enabled,\n    hasEventSubscriptions,\n    addEventListeners,\n    removeAllEventSubscriptions\n  ]);\n\n  // run this effect after every render\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n\n  return {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n","import {\n  ReactNode,\n  createContext,\n  MutableRefObject,\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  createElement\n} from \"react\";\nimport warning from \"tiny-warning\";\n\ntype Registration = {\n  shouldCloseWhenClickedOutside: (event: MouseEvent) => boolean;\n  closeChild: () => void;\n};\n\ntype Registrations = Set<Registration>;\n\ntype RegisterFn = (registration: Registration) => () => void;\n\ntype GroupContextType = {} | RegisterFn;\n\nconst GroupContext = createContext({} as GroupContextType);\n\ntype GroupProviderProps = {\n  children: ReactNode;\n  registrations: MutableRefObject<Registrations>;\n};\n\n// Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\nexport function GroupProvider({ children, registrations }: GroupProviderProps) {\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  const handleRegister = useCallback(\n    function register(registration: Registration) {\n      registrations.current.add(registration);\n\n      return () => registrations.current.delete(registration);\n    },\n    [registrations]\n  );\n\n  return createElement(\n    GroupContext.Provider,\n    { value: handleRegister },\n    children\n  );\n}\n\n// asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\nfunction getShouldCloseAccordingToChildren(\n  registrations: Registrations,\n  event: MouseEvent\n) {\n  for (const { shouldCloseWhenClickedOutside } of registrations) {\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype UseGroup = {\n  isOpen: boolean;\n  onOutsideClick?: () => void;\n  onParentClose?: () => void;\n};\n\n/**\n * Responsible for close behavior\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\n *\n * Behavior:\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\n *   the child layers whether they would close, and will handle accordingly. The parent may\n *   command the children to close indirectly with the help of `onParentClose`\n * - When the parent just was closed, it will make sure that any children will also close\n *   with the help of `onParentClose`\n */\nexport function useGroup({ isOpen, onOutsideClick, onParentClose }: UseGroup) {\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  const trigger = useRef<HTMLElement>(null!);\n  const layer = useRef<HTMLElement>(null!);\n\n  // a Set which keeps track of callbacks given by the child layers through context\n  const registrations = useRef<Registrations>(new Set());\n\n  // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n  const possibleRegisterFn = useContext(GroupContext);\n\n  // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n  const shouldCloseWhenClickedOutside = useCallback(\n    function shouldCloseWhenClickedOutside(event: MouseEvent) {\n      const target = event.target as HTMLElement;\n\n      const clickedOnTrigger =\n        trigger.current && trigger.current.contains(target);\n      const clickedOnLayer = layer.current && layer.current.contains(target);\n\n      const shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(\n        registrations.current,\n        event\n      );\n\n      // when clicked on own layer, but the child would have closed ->\n      // let child close\n      if (clickedOnLayer && shouldCloseAccordingToChildren) {\n        registrations.current.forEach(({ closeChild }) => closeChild());\n      }\n\n      return (\n        !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren\n      );\n    },\n    [trigger, layer, registrations]\n  );\n\n  // registration stuff\n  useEffect(() => {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    }\n\n    // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside,\n      closeChild: () => {\n        warning(\n          onParentClose,\n          `react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.`\n        );\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [\n    possibleRegisterFn,\n    shouldCloseWhenClickedOutside,\n    onParentClose,\n    registrations\n  ]);\n\n  // document click handling\n  useEffect(() => {\n    const isChild = typeof possibleRegisterFn === \"function\";\n    const shouldNotListen = !isOpen || !onOutsideClick || isChild;\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick!();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return () => document.removeEventListener(\"click\", handleClick, true);\n  }, [\n    isOpen,\n    onOutsideClick,\n    shouldCloseWhenClickedOutside,\n    possibleRegisterFn\n  ]);\n\n  // When this 'useLayer' gets closed -> tell child layers to close as well\n  useEffect(() => {\n    if (!isOpen) {\n      registrations.current.forEach(({ closeChild }) => closeChild());\n    }\n  }, [isOpen]);\n\n  return {\n    closeOnOutsideClickRefs: {\n      trigger,\n      layer\n    },\n    registrations\n  };\n}\n","export type BoundSideProp = \"top\" | \"left\" | \"bottom\" | \"right\";\nexport type SideProp = BoundSideProp | \"center\";\ntype SizeProp = \"width\" | \"height\";\ntype CssProp = \"top\" | \"left\";\n\nconst OPPOSITES: Record<SideProp, SideProp> = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nclass SideBase<T extends SideProp> {\n  constructor(\n    readonly prop: T,\n    readonly opposite: SideBase<T>,\n    readonly isHorizontal: boolean,\n    readonly sizeProp: SizeProp,\n    readonly oppositeSizeProp: SizeProp,\n    readonly cssProp: CssProp,\n    readonly oppositeCssProp: CssProp,\n    readonly isCenter: boolean,\n    readonly isPush: boolean // left | top\n  ) {}\n\n  factor(value: number) {\n    return value * (this.isPush ? 1 : -1);\n  }\n\n  isOppositeDirection(side: SideBase<any>) {\n    return this.isHorizontal !== side.isHorizontal;\n  }\n}\n\nfunction createSide<T extends SideProp>(\n  prop: T,\n  recursive = true\n): SideBase<T> {\n  const isHorizontal = [\"left\", \"right\"].includes(prop);\n\n  return new SideBase<T>(\n    prop,\n    recursive ? createSide<T>((OPPOSITES as any)[prop], false) : null!,\n    isHorizontal,\n    isHorizontal ? \"width\" : \"height\",\n    isHorizontal ? \"height\" : \"width\",\n    isHorizontal ? \"left\" : \"top\",\n    isHorizontal ? \"top\" : \"left\",\n    prop === \"center\",\n    ![\"right\", \"bottom\"].includes(prop)\n  );\n}\n\nexport type BoundSideType = SideBase<BoundSideProp>;\nexport type SideType = SideBase<SideProp>;\n\nexport const BoundSide = {\n  top: createSide(\"top\") as BoundSideType,\n  bottom: createSide(\"bottom\") as BoundSideType,\n  left: createSide(\"left\") as BoundSideType,\n  right: createSide(\"right\") as BoundSideType\n};\n\nexport const Side = {\n  ...(BoundSide as {\n    top: SideType;\n    left: SideType;\n    bottom: SideType;\n    right: SideType;\n  }),\n  center: createSide(\"center\")\n};\n","export interface IBoundsOffsets {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n}\n\nconst SIDES = [\"top\", \"left\", \"bottom\", \"right\"] as (keyof IBoundsOffsets)[];\n\n/**\n * A class containing the positional properties which represent the distance\n * between two Bounds instances for each side\n */\nexport class BoundsOffsets implements IBoundsOffsets {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n\n  constructor(offsets: IBoundsOffsets) {\n    return Object.assign(this, offsets);\n  }\n\n  /**\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\n   * by taking the smallest value for each side\n   * @param boundsOffsets list of BoundsOffsets instances\n   */\n  static mergeSmallestSides(boundsOffsets: BoundsOffsets[]): BoundsOffsets {\n    const [first, ...rest] = boundsOffsets;\n\n    if (!first) {\n      throw new Error(\n        \"Please provide at least 1 bounds objects in order to merge\"\n      );\n    }\n\n    const result: IBoundsOffsets = Object.fromEntries(\n      SIDES.map(side => [side, first[side]])\n    ) as any;\n\n    for (const boundsOffset of rest) {\n      for (const side of SIDES) {\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n\n  /**\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\n   * fits perfectly within a parent Bounds instance\n   */\n  get allSidesArePositive(): boolean {\n    return SIDES.every(side => this[side] >= 0);\n  }\n\n  /**\n   * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\n   * visible in respect to a parent Bounds instance\n   */\n  get negativeSides(): Partial<IBoundsOffsets> {\n    return Object.fromEntries(\n      SIDES.filter(side => this[side] < 0).map(side => [side, this[side]])\n    ) as Partial<IBoundsOffsets>;\n  }\n}\n","import { BoundSide, BoundSideProp, BoundSideType } from \"./Sides\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { getPixelValue } from \"./util\";\n\n/**\n * Utility function that returns sum of various computed styles\n * @param propertyValues list of computed styles (ie. '12px')\n */\nfunction sumOfPropertyValues(...propertyValues: string[]) {\n  return propertyValues.reduce(\n    (sum, propertyValue) =>\n      sum + (propertyValue ? getPixelValue(propertyValue!) : 0),\n    0\n  );\n}\n\nexport interface IBounds {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport function boundsToObject({\n  top,\n  left,\n  right,\n  bottom,\n  width,\n  height\n}: IBounds): IBounds {\n  return { top, left, right, bottom, width, height };\n}\n\nconst EMPTY: IBounds = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n\n/**\n * A class containing the positional properties of the native DOM's ClientRect\n * (`element.getBoundingClientRect()`), together with some utility methods\n */\nexport class Bounds implements IBounds {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n  width!: number;\n  height!: number;\n\n  /**\n   * Creates a new Bounds class\n   * @param bounds An object that adheres to the `IBounds` interface\n   */\n  static create(bounds: IBounds): Bounds {\n    return new Bounds(bounds);\n  }\n\n  /**\n   * Creates a new Bounds class from a DOM-element\n   * @param element reference to the DOM-element\n   * @param options optional options object\n   */\n  static fromElement(\n    element: HTMLElement,\n    options: {\n      /** should transforms like 'scale' taken into account? Defaults to `true` */\n      withTransform?: boolean;\n      /** reference to the window-object (needed when working with iframes for instance). Defaults to `window` */\n      environment?: Window;\n      /** should the elements scrollbars be included? Defaults to `true` */\n      withScrollbars?: boolean;\n    } = {}\n  ): Bounds {\n    const {\n      withTransform = true,\n      environment = window,\n      withScrollbars = true\n    } = options;\n\n    const plain: IBounds = boundsToObject(element.getBoundingClientRect());\n\n    let bounds: Bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      const {\n        width,\n        height,\n        boxSizing,\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom\n      } = environment.getComputedStyle(element);\n\n      const boxWidth =\n        boxSizing === \"border-box\"\n          ? getPixelValue(width!)\n          : sumOfPropertyValues(\n              width,\n              borderLeft,\n              borderRight,\n              paddingLeft,\n              paddingRight\n            );\n\n      const boxHeight =\n        boxSizing === \"border-box\"\n          ? getPixelValue(height!)\n          : sumOfPropertyValues(\n              height,\n              borderTop,\n              borderBottom,\n              paddingTop,\n              paddingBottom\n            );\n\n      bounds = new Bounds({\n        ...bounds,\n        width: boxWidth,\n        height: boxHeight\n      });\n    }\n\n    if (!withScrollbars) {\n      const scrollbarWidth = bounds.width - element.clientWidth;\n      const scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n\n  /**\n   * Creates an empty Bounds class\n   */\n  static empty(): Bounds {\n    return new Bounds();\n  }\n\n  /**\n   * Creates a Bounds class from the window's dimensions\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\n   */\n  static fromWindow(environment?: Window): Bounds {\n    const scrollingElement =\n      environment?.document.scrollingElement ??\n      environment?.document.documentElement;\n    const { clientWidth: width = 0, clientHeight: height = 0 } =\n      scrollingElement ?? {};\n\n    return new Bounds({ width, height, right: width, bottom: height });\n  }\n\n  protected constructor(bounds: Partial<IBounds> = {}) {\n    return Object.assign(this, EMPTY, bounds);\n  }\n\n  /**\n   * Returns the square surface of the bounds in pixels\n   */\n  get surface(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * Returns a plain object containing only positional properties\n   */\n  toObject(): IBounds {\n    return boundsToObject(this);\n  }\n\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param bounds partial bounds which should be merged\n   */\n  merge(bounds: Partial<IBounds>): Bounds;\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param mergeFn callback which takes the current bounds and returns new merged bounds\n   */\n  merge(mergeFn: (current: IBounds) => Partial<IBounds>): Bounds;\n  merge(partialBoundsOrMergeFn: unknown): Bounds {\n    const current = this.toObject();\n    return new Bounds({\n      ...current,\n      ...(typeof partialBoundsOrMergeFn === \"function\"\n        ? partialBoundsOrMergeFn(current)\n        : partialBoundsOrMergeFn)\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\n   * @param bounds partial IBounds object to substract with\n   */\n  substract(bounds: Partial<IBounds>): Bounds {\n    const result = this.toObject();\n\n    const entries = Object.entries(bounds) as [keyof IBounds, number][];\n\n    for (const [prop, value] of entries) {\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        const boundSide = BoundSide[prop as BoundSideProp];\n        // decide if we should add or substract\n        result[prop] += boundSide.factor(value);\n        // make sure that the size-properties are also updated\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n\n  /**\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\n   * (child -> parent)\n   * @param child child bounds instance\n   */\n  offsetsTo(child: Bounds): BoundsOffsets {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by mapping over each bound-side\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\n   */\n  mapSides(\n    mapper: (boundSide: BoundSideType, value: number) => number\n  ): Bounds {\n    const result = this.toObject();\n    const boundSides = Object.values(BoundSide) as BoundSideType[];\n    for (const boundSide of boundSides) {\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n    return new Bounds(result);\n  }\n}\n","import { BoundSideType, SideType, BoundSide, BoundSideProp } from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { PositionConfig, Offsets } from \"./types\";\nimport { Bounds, IBounds } from \"./Bounds\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { limit } from \"./util\";\n\n/**\n * Class for various calculations based on a placement-type. I.e 'top-left';\n */\nexport class Placement {\n  protected subjectsBounds!: SubjectsBounds;\n  private _cachedLayerBounds: Bounds | null = null;\n  private _cachedContainerOffsets: BoundsOffsets | null = null;\n\n  constructor(\n    public readonly primary: SideType,\n    public readonly secondary: SideType,\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"],\n    private readonly offsets: Offsets\n  ) {\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n\n  /**\n   * Set subjectsBounds that are specific for this placement\n   * @param subjectBounds original SubjectBounds instance\n   * @param layerDimensions possible config prodvided by the user\n   */\n  private setSubjectsBounds(\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"]\n  ): void {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    }\n\n    // get anticipated layer-dimensions provided by the user\n    const dimensions =\n      // if the user passed a callback, call it with the layerSide corresponding to\n      // the placement\n      typeof layerDimensions === \"function\"\n        ? layerDimensions(this.primary.prop)\n        : layerDimensions;\n\n    // create new SubjectsBounds instance by merging our newly create layer-bounds\n    this.subjectsBounds = subjectBounds.merge({\n      layer: {\n        ...subjectBounds.layer,\n        ...dimensions\n      }\n    });\n  }\n\n  /**\n   * Returns the string respresentation of this placement (ie. 'top-start')\n   */\n  public get type(): PlacementType {\n    return `${this.primary.prop}-${\n      this.secondary.prop === \"center\"\n        ? \"center\"\n        : [\"bottom\", \"right\"].includes(this.secondary.prop)\n        ? \"end\"\n        : \"start\"\n    }` as PlacementType;\n  }\n\n  /**\n   * Calculates the actual boundaries based on the placement\n   * @param secondaryOffset optional offset on the secondary-side\n   */\n  public getLayerBounds(secondaryOffset = 0): Bounds {\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    const { primary, secondary, subjectsBounds } = this;\n    const { trigger, layer, arrow } = subjectsBounds;\n    const { isHorizontal, oppositeCssProp, oppositeSizeProp, prop, opposite } =\n      primary as BoundSideType;\n\n    const result = Bounds.empty() as IBounds;\n\n    // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n\n    // PRIMARY STUFF\n\n    // bottom = trigger.top + 8;\n    result[opposite.prop] =\n      trigger[prop] - primary.factor(this.offsets.trigger);\n\n    // top = bottom - layer.height\n    result[prop] =\n      result[opposite.prop] - primary.factor(layer[primary.sizeProp]);\n\n    // SECONDARY STUFF\n\n    // arrowOffsetBase = 4\n    const arrowOffsetBase = this.offsets.arrow * 2;\n\n    // limitMin = trigger.left - (layer.width - arrow.width) + 4\n    let limitMin =\n      trigger[oppositeCssProp] -\n      (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) +\n      arrowOffsetBase;\n    // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n    let limitMax =\n      trigger[oppositeCssProp] +\n      (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) -\n      arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      const propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      const propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right)\n        .prop;\n\n      // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[propertyA] = limit(\n        trigger[propertyA] +\n          trigger[oppositeSizeProp] / 2 -\n          layer[oppositeSizeProp] / 2 +\n          secondaryOffset,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      const sec = secondary as BoundSideType;\n\n      const triggerValue = trigger[sec.prop];\n\n      // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n      const arrowCompensation =\n        triggerValue < limitMin\n          ? limitMin - triggerValue\n          : triggerValue > limitMax\n          ? limitMax - triggerValue\n          : 0;\n\n      // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[sec.prop] = limit(\n        triggerValue + secondaryOffset + arrowCompensation,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[sec.opposite.prop] =\n        result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    }\n\n    // set the correct dimensions\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    // create new bounds object\n    const layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n\n  /**\n   * Checks whether the trigger is bigger on the opposite side\n   * ie. placement \"top-start\" -> has trigger a bigger width?\n   */\n  public get triggerIsBigger() {\n    const { isHorizontal } = this.secondary;\n    const { triggerHasBiggerWidth, triggerHasBiggerHeight } =\n      this.subjectsBounds;\n\n    return (\n      (isHorizontal && triggerHasBiggerWidth) ||\n      (!isHorizontal && triggerHasBiggerHeight)\n    );\n  }\n\n  /**\n   * Checks whether the placement fits within all it's container (including container-offset)\n   */\n  public get fitsContainer(): boolean {\n    return this.getContainerOffsets().allSidesArePositive;\n  }\n\n  /**\n   * Returns the surface in square pixels of the visible part of the layer\n   */\n  public get visibleSurface(): number {\n    const layerBounds = this.getLayerBounds();\n    const containerOffsets = this.getContainerOffsets(layerBounds);\n\n    const substract = containerOffsets.negativeSides;\n    for (const side in substract) {\n      // @ts-ignore\n      substract[side] = -substract[side]; // make positive for substraction;\n    }\n\n    return layerBounds.substract(substract).surface;\n  }\n\n  /**\n   * Returns a BoundSide by looking at the most negative offset that is the opposite direction\n   */\n  public get secondaryOffsetSide(): BoundSideType | null {\n    // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n    // the only negative offsets on the opposite side are { left: -20, right: -10 }\n    // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n    const containerOffsets = this.getContainerOffsets();\n\n    const [mostNegativeSide] =\n      Object.entries(containerOffsets.negativeSides)\n        .map(\n          ([side, value]) => [BoundSide[side as BoundSideProp], value] as const\n        )\n        .filter(([side]) => this.primary.isOppositeDirection(side))\n        .sort(([, a], [, b]) => b! - a!)?.[0] ?? [];\n\n    return mostNegativeSide || null;\n  }\n\n  /**\n   * returns getLayerBounds(), including container-offsets\n   */\n  private getLayerCollisionBounds(): Bounds {\n    const { container } = this.offsets;\n\n    return this.getLayerBounds()\n      .mapSides((side, value) => (value -= side.factor(container)))\n      .merge(({ width, height }) => ({\n        width: width + container * 2,\n        height: height + container * 2\n      }));\n  }\n\n  /**\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\n   * negative scenario\n   */\n  public getContainerOffsets(layerBounds?: Bounds): BoundsOffsets {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    const subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n\n    const offsets = BoundsOffsets.mergeSmallestSides(\n      subjectBounds.layerOffsetsToScrollContainers\n    );\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  }\n}\n\nexport class PlacementCenter extends Placement {\n  getLayerBounds(): Bounds {\n    const { trigger, layer } = this.subjectsBounds;\n\n    const result = Bounds.empty() as IBounds;\n\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    return result as Bounds;\n  }\n}\n","import { limit } from \"./util\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { Placement } from \"./Placement\";\n\n// how much pixels is the center of layer removed from edge of trigger?\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n) {\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n\n  const [sideA, sideB] = !placement.primary.isHorizontal\n    ? ([\"left\", \"right\"] as const)\n    : ([\"top\", \"bottom\"] as const);\n\n  const offsetA =\n    layer[sideA] +\n    layer[sizeProperty] / 2 -\n    trigger[sideA] -\n    arrow[sizeProperty] / 2 -\n    arrowOffset;\n  const offsetB =\n    layer[sideB] -\n    layer[sizeProperty] / 2 -\n    trigger[sideB] +\n    arrow[sizeProperty] / 2 +\n    arrowOffset;\n\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nconst STYLE_BASE: React.CSSProperties = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null!,\n  right: null!,\n  top: null!,\n  bottom: null!\n};\n\nexport function getArrowStyle(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n): React.CSSProperties {\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n  const triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n\n  const min = arrowOffset + arrow[sizeProperty] / 2;\n  const max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n\n  const negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(\n    subjectsBounds,\n    placement,\n    arrowOffset\n  );\n\n  const primarySide = placement.primary.prop;\n  const secondarySide = placement.primary.oppositeCssProp;\n\n  const secondaryValue = triggerIsBigger\n    ? layer[sizeProperty] / 2 + negativeOffset\n    : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n\n  return {\n    ...STYLE_BASE,\n    [primarySide]: \"100%\",\n    [secondarySide]: limit(secondaryValue, min, max)\n  };\n}\n","import { CSSProperties } from \"react\";\nimport {\n  BoundSide,\n  Side,\n  BoundSideType,\n  SideType,\n  BoundSideProp,\n  SideProp\n} from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { Placement, PlacementCenter } from \"./Placement\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport {\n  PositionConfig,\n  Offsets,\n  ScrollOffsets,\n  BorderOffsets,\n  DisappearType,\n  Styles\n} from \"./types\";\nimport { Bounds } from \"./Bounds\";\nimport { getArrowStyle } from \"./getArrowStyle\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\n\n/**\n * Class mostly concerned about calculating and finding the right placement\n */\nexport class Placements {\n  protected constructor(\n    public readonly placements: Placement[],\n    private config: PositionConfig,\n    private subjectsBounds: SubjectsBounds\n  ) {}\n\n  /**\n   * Converts a placement-type into a primary-side and a secondary-side\n   */\n  static getSidesFromPlacementType(\n    type: PlacementType\n  ): [BoundSideType, SideType] {\n    let [a, b] = type.split(\"-\") as unknown as [\n      keyof typeof BoundSide,\n      \"start\" | \"center\" | \"end\"\n    ];\n\n    const primary = BoundSide[a];\n    let secondary: SideType;\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n\n  /**\n   * Main static method to create a Placements instance\n   * @param subjectsBounds instance of the SubjectsBounds class\n   * @param config config provided by the user\n   */\n  static create(\n    subjectsBounds: SubjectsBounds,\n    config: PositionConfig\n  ): Placements {\n    // create offsets-object from user config\n    const offsets: Offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    };\n\n    // function which creates a prioritized list of possible placments\n    // by looking at user-config\n    function getListOfPlacements(preferedPlacement = config.placement) {\n      const [primary, secondary] =\n        Placements.getSidesFromPlacementType(preferedPlacement);\n\n      const preferredSide =\n        BoundSide[primary.isHorizontal ? config.preferY : config.preferX];\n\n      // some priorities may alter when the trigger is bigger\n      const triggerIsBigger =\n        (!primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth) ||\n        (primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight);\n\n      // utility function which constructs a placement by primary and secondary sides\n      function placementFrom(\n        primary: BoundSideType,\n        secondary: SideType\n      ): Placement {\n        return new Placement(\n          primary,\n          secondary,\n          subjectsBounds,\n          config.layerDimensions,\n          offsets\n        );\n      }\n\n      // creating the list\n      let list: Placement[] = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(\n        primary,\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[2] = placementFrom(\n        primary,\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n      list[3] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[6] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[7] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        Side.center\n      );\n      list[8] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[11] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n\n      // only include placements that are part of 'possible-placements'\n      list = list.filter(\n        placement =>\n          placement.type === config.placement ||\n          config.possiblePlacements.includes(placement.type)\n      );\n\n      return list;\n    }\n\n    // treat placement 'center' a little bit different\n    if (config.placement === \"center\") {\n      return new Placements(\n        [\n          new PlacementCenter(\n            Side.center,\n            Side.center,\n            subjectsBounds,\n            config.layerDimensions,\n            offsets\n          ),\n          ...getListOfPlacements(\n            `${config.preferY}-${config.preferX}` as PlacementType\n          )\n        ],\n        config,\n        subjectsBounds\n      );\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  }\n\n  private filterPlacementsBySide(side: SideType): Placement[] {\n    return this.placements.filter(placement => placement.primary === side);\n  }\n\n  private findFirstPlacementThatFits(): Placement | undefined {\n    return this.placements.find(placement => placement.fitsContainer);\n  }\n\n  private placementWithBiggestVisibleSurface(): Placement {\n    const [{ placement: placementWithBiggestSurface }] = this.placements\n      .map(placement => ({\n        placement,\n        surface: placement.visibleSurface\n      }))\n      // sort -> biggest surface first\n      .sort((a, b) => b.surface - a.surface);\n\n    return placementWithBiggestSurface;\n  }\n\n  private findSuitablePlacement(): Placement {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return (\n      this.findFirstPlacementThatFits() ||\n      this.placementWithBiggestVisibleSurface()\n    );\n  }\n\n  /**\n   * secondary offset: the number of pixels between the edge of the\n   * scroll-container and the current placement, on the side of the layer\n   * that didn't fit.\n   * Eventually this secondary offset gets added / subtracted from the\n   * placement that does fit in order to move the layer closer to the\n   * position of the placement that just would not fit.\n   * This creates the effect that the layer is moving gradually from one\n   * placement to the next as the users scrolls the page or scroll-container\n   */\n  private getSecondaryOffset(placement: Placement): number {\n    const { auto, snap } = this.config;\n\n    // return early when we're not interested...\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    }\n\n    // if current placement fits and is prefered placement...\n    // return early\n    const placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    const currentPlacementHasHighestPriority =\n      placementsOnSameSide.indexOf(placement) === 0;\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    const firstPlacementThatDoesNotFit = placementsOnSameSide.find(\n      placement => !placement.fitsContainer\n    );\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n    const secondaryOffsetSide =\n      firstPlacementThatDoesNotFit.secondaryOffsetSide!;\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    const containerOffsets = placement.getContainerOffsets();\n\n    // determine whether we should add or substract the secondary-offset\n    const { secondary } = placement;\n    let factor: number;\n    if (\n      placement.triggerIsBigger ||\n      firstPlacementThatDoesNotFit === placement\n    ) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor =\n        secondary === Side.left ||\n        ([Side.top, Side.center].includes(secondary) &&\n          secondaryOffsetSide.isPush)\n          ? -1\n          : 1;\n    }\n\n    // get number of pixels between placement that did not fit and current\n    // placement\n    const secondaryOffset = containerOffsets[secondaryOffsetSide!.prop];\n\n    return secondaryOffset * factor;\n  }\n\n  private getStyles(\n    layerBounds: Bounds,\n    placement: Placement,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ): Styles {\n    const layerStyleBase: CSSProperties = {\n      willChange: \"top, left, width, height\"\n    };\n\n    const arrow = getArrowStyle(\n      this.subjectsBounds.merge({ layer: layerBounds }),\n      placement,\n      this.config.arrowOffset\n    );\n\n    const layer: CSSProperties = this.config.overflowContainer\n      ? {\n          ...layerStyleBase,\n          position: \"fixed\",\n          top: layerBounds.top,\n          left: layerBounds.left\n        }\n      : {\n          ...layerStyleBase,\n          position: \"absolute\",\n          top:\n            layerBounds.top -\n            this.subjectsBounds.parent.top +\n            scrollOffsets.top -\n            borderOffsets.top,\n          left:\n            layerBounds.left -\n            this.subjectsBounds.parent.left +\n            scrollOffsets.left -\n            borderOffsets.left\n        };\n\n    return {\n      arrow,\n      layer\n    };\n  }\n\n  private getHasDisappeared(layerBounds: Bounds): DisappearType | null {\n    const subject = this.config.overflowContainer\n      ? this.subjectsBounds.trigger\n      : layerBounds;\n\n    const containerOffsets = BoundsOffsets.mergeSmallestSides(\n      this.subjectsBounds.offsetsToScrollContainers(subject, true)\n    );\n\n    const entries = Object.entries(\n      containerOffsets.negativeSides\n    ) as unknown as [BoundSideProp, number][];\n\n    const hasFullyDisappeared = entries.some(([prop, value]) => {\n      const side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  }\n\n  public result(scrollOffsets: ScrollOffsets, borderOffsets: BorderOffsets) {\n    const suitablePlacement = this.findSuitablePlacement();\n    const secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    const layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    const styles = this.getStyles(\n      layerBounds,\n      suitablePlacement,\n      scrollOffsets,\n      borderOffsets\n    );\n    const layerSide = suitablePlacement.primary.prop as SideProp;\n\n    return {\n      styles,\n      layerSide,\n      placement: suitablePlacement,\n      layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  }\n}\n","import { Bounds, IBounds, boundsToObject } from \"./Bounds\";\n\ninterface ISubjectsBounds {\n  trigger: IBounds;\n  layer: IBounds;\n  arrow: IBounds;\n  parent: IBounds;\n  window: IBounds;\n  scrollContainers: IBounds[];\n}\n\nexport class SubjectsBounds implements ISubjectsBounds {\n  public readonly trigger!: Bounds;\n  public readonly layer!: Bounds;\n  public readonly arrow!: Bounds;\n  public readonly parent!: Bounds;\n  public readonly window!: Bounds;\n  public readonly scrollContainers!: Bounds[];\n\n  private constructor(\n    subjectsBounds: ISubjectsBounds,\n    private readonly overflowContainer: boolean\n  ) {\n    Object.assign(this, subjectsBounds);\n  }\n\n  static create(\n    environment: Window,\n    layer: HTMLElement,\n    trigger: HTMLElement,\n    parent: HTMLElement | undefined,\n    arrow: HTMLElement | null,\n    scrollContainers: HTMLElement[],\n    overflowContainer: boolean,\n    getTriggerBounds?: () => IBounds\n  ) {\n    const window = Bounds.fromWindow(environment);\n\n    return new SubjectsBounds(\n      {\n        layer: Bounds.fromElement(layer, {\n          environment,\n          withTransform: false\n        }),\n        trigger: getTriggerBounds\n          ? Bounds.create(boundsToObject(getTriggerBounds()))\n          : Bounds.fromElement(trigger),\n        arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n        parent: parent ? Bounds.fromElement(parent) : window,\n        window,\n        scrollContainers: [\n          window,\n          ...scrollContainers.map(container =>\n            Bounds.fromElement(container, { withScrollbars: false })\n          )\n        ]\n      },\n      overflowContainer\n    );\n  }\n\n  merge(subjectsBounds: Partial<ISubjectsBounds>) {\n    return new SubjectsBounds(\n      {\n        ...this,\n        ...subjectsBounds\n      },\n      this.overflowContainer\n    );\n  }\n\n  get layerOffsetsToScrollContainers() {\n    return this.offsetsToScrollContainers(this.layer);\n  }\n\n  get triggerHasBiggerWidth() {\n    return this.trigger.width > this.layer.width;\n  }\n\n  get triggerHasBiggerHeight() {\n    return this.trigger.height > this.layer.height;\n  }\n\n  offsetsToScrollContainers(subject: Bounds, allContainers = false) {\n    const scrollContainers =\n      this.overflowContainer && !allContainers\n        ? [this.window]\n        : this.scrollContainers;\n\n    return scrollContainers.map(scrollContainer =>\n      scrollContainer.offsetsTo(subject)\n    );\n  }\n}\n","import {\n  useCallback,\n  useState,\n  useRef,\n  createElement,\n  ReactNode,\n  ReactPortal,\n  MutableRefObject,\n  CSSProperties,\n  useEffect\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport warning from \"tiny-warning\";\nimport {\n  Options,\n  LayerSide,\n  Styles,\n  ScrollOffsets,\n  BorderOffsets,\n  PositionConfig,\n  RefCallback,\n  Container\n} from \"./types\";\nimport { useTrackElements, OnChangeElements } from \"./useTrackElements\";\nimport { useGroup, GroupProvider } from \"./useGroup\";\nimport { PlacementType, PLACEMENT_TYPES } from \"./PlacementType\";\nimport { Placements } from \"./Placements\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { useLastState } from \"./hooks\";\nimport { isSet, mergeRefs } from \"./util\";\n\nlet GLOBAL_CONTAINER: HTMLElement | null = null;\n\nexport function setGlobalContainer(container: Container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  warning(\n    !(GLOBAL_CONTAINER instanceof HTMLElement),\n    `react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.`\n  );\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  warning(\n    GLOBAL_CONTAINER instanceof HTMLElement,\n    `react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element`\n  );\n}\n\nexport type LayerProps = { ref: RefCallback; style: Styles[\"layer\"] };\nexport type TriggerProps = { ref: RefCallback };\nexport type UseLayerArrowProps = {\n  ref: MutableRefObject<any> | RefCallback;\n  layerSide: LayerSide;\n  style: Styles[\"arrow\"];\n};\n\nexport type UseLayerProps = {\n  renderLayer: (children: ReactNode) => ReactPortal | null;\n  triggerProps: TriggerProps;\n  layerProps: LayerProps;\n  arrowProps: UseLayerArrowProps;\n  layerSide: LayerSide;\n  triggerBounds: ClientRect | null;\n};\n\ntype State = {\n  layerSide: LayerSide;\n  styles: Styles;\n};\n\nexport const DEFAULT_OPTIONS: Required<\n  Omit<\n    Options,\n    | \"ResizeObserver\"\n    | \"environment\"\n    | \"onParentClose\"\n    | \"onOutsideClick\"\n    | \"onDisappear\"\n    | \"isOpen\"\n    | \"layerDimensions\"\n  >\n> = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: PLACEMENT_TYPES as unknown as PlacementType[],\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined!,\n  trigger: undefined!\n};\n\nexport function useLayer({\n  isOpen = false,\n  overflowContainer = DEFAULT_OPTIONS.overflowContainer,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ResizeObserver: ResizeObserverPolyfill,\n  placement = DEFAULT_OPTIONS.placement,\n  possiblePlacements = DEFAULT_OPTIONS.possiblePlacements,\n  preferX = DEFAULT_OPTIONS.preferX,\n  preferY = DEFAULT_OPTIONS.preferY,\n  auto = DEFAULT_OPTIONS.auto,\n  snap = DEFAULT_OPTIONS.snap,\n  triggerOffset = DEFAULT_OPTIONS.triggerOffset,\n  containerOffset = DEFAULT_OPTIONS.containerOffset,\n  arrowOffset = DEFAULT_OPTIONS.arrowOffset,\n  container = DEFAULT_OPTIONS.container,\n  layerDimensions = null,\n  onDisappear,\n  onOutsideClick,\n  onParentClose,\n  trigger: triggerOption\n}: Options): UseLayerProps {\n  // initialize styles\n  const [state, setState] = useState<State>(() => ({\n    layerSide:\n      placement === \"center\"\n        ? \"center\"\n        : Placements.getSidesFromPlacementType(placement)[0].prop,\n    styles: {\n      layer: {\n        position: overflowContainer ? \"fixed\" : \"absolute\",\n        top: 0,\n        left: 0\n      },\n      arrow: {\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }\n  }));\n\n  const triggerBoundsRef = useRef<HTMLElement>(null!);\n\n  // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n  const lastState = useLastState(state, isOpen);\n\n  // track invalidations for scheduled position updates\n  const repositioningToken = useRef({ cancelled: false });\n  useEffect(() => {\n    return () => {\n      // when this hook unmounts, make sure to cancel any scheduled position updates\n      repositioningToken.current.cancelled = true;\n    };\n  }, []);\n\n  // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n  const handlePositioning = useCallback(\n    function handlePositioning(\n      { arrow, layer, scrollContainers, trigger }: OnChangeElements,\n      scrollOffsets: ScrollOffsets,\n      borderOffsets: BorderOffsets\n    ) {\n      const parent = scrollContainers[0];\n\n      const subjectsBounds = SubjectsBounds.create(\n        environment!,\n        layer,\n        trigger,\n        parent,\n        arrow,\n        scrollContainers,\n        overflowContainer,\n        triggerOption?.getBounds\n      );\n\n      const config: PositionConfig = {\n        placement,\n        possiblePlacements,\n        auto,\n        layerDimensions,\n        arrowOffset,\n        containerOffset,\n        triggerOffset,\n        preferX,\n        preferY,\n        snap,\n        overflowContainer\n      };\n\n      const { hasDisappeared, layerSide, styles } = Placements.create(\n        subjectsBounds,\n        config\n      ).result(scrollOffsets, borderOffsets);\n\n      const newState: State = {\n        layerSide,\n        styles\n      };\n\n      if (!lastState.current || didStateChange(lastState.current, newState)) {\n        lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n        /**\n         * Throttle state updates slightly by delaying them using an immediately\n         * resolved promise, only applying them if there is no later update.\n         * This helps for multiple updates that happens synchronously one after another.\n         */\n        repositioningToken.current.cancelled = true;\n        const token = { cancelled: false };\n        repositioningToken.current = token;\n\n        Promise.resolve().then(() => {\n          if (!token.cancelled) {\n            setState(newState);\n          }\n        });\n      }\n\n      if (isSet(hasDisappeared) && isSet(onDisappear)) {\n        onDisappear(hasDisappeared);\n      }\n    },\n    [\n      arrowOffset,\n      auto,\n      containerOffset,\n      environment,\n      layerDimensions,\n      onDisappear,\n      overflowContainer,\n      placement,\n      possiblePlacements,\n      preferX,\n      preferY,\n      snap,\n      triggerOffset,\n      lastState,\n      triggerOption\n    ]\n  );\n\n  const { triggerRef, layerRef, arrowRef, closestScrollContainer } =\n    useTrackElements({\n      ResizeObserverPolyfill,\n      environment,\n      enabled: isOpen,\n      overflowContainer,\n      onChange: handlePositioning,\n      triggerOption\n    });\n\n  const { closeOnOutsideClickRefs, registrations } = useGroup({\n    isOpen,\n    onOutsideClick,\n    onParentClose\n  });\n\n  const props: UseLayerProps = {\n    triggerProps: Boolean(triggerOption)\n      ? ({} as any) // when using the `trigger` option, make `triggerProps` useless\n      : {\n          ref: mergeRefs(\n            triggerRef,\n            closeOnOutsideClickRefs.trigger,\n            triggerBoundsRef\n          )\n        },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen\n      ? triggerOption\n        ? triggerOption.getBounds()\n        : triggerBoundsRef.current?.getBoundingClientRect()\n      : null,\n    renderLayer: children =>\n      typeof document !== \"undefined\"\n        ? createPortal(\n            createElement(GroupProvider, { registrations, children }),\n            overflowContainer || !closestScrollContainer\n              ? getContainerElement(container)\n              : closestScrollContainer\n          )\n        : null\n  };\n\n  return props;\n}\n\nfunction didStateChange(previous: State, next: State): boolean {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  const styleProps: Array<keyof CSSProperties> = [\n    \"position\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\"\n  ];\n  for (const prop of styleProps) {\n    if (\n      previous.styles.layer[prop] !== next.styles.layer[prop] ||\n      previous.styles.arrow[prop] !== next.styles.arrow[prop]\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container?: Container): HTMLElement {\n  let element: HTMLElement;\n\n  if (typeof container === \"function\") {\n    element = container();\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\n        `react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container)!;\n    if (!element) {\n      throw new Error(\n        `react-laag: You've passed element with id '${container}' to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID)!;\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = `\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      `;\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n","export const PLACEMENT_TYPES: PlacementType[] = [\n  \"bottom-start\",\n  \"bottom-end\",\n  \"bottom-center\",\n  \"top-start\",\n  \"top-center\",\n  \"top-end\",\n  \"left-end\",\n  \"left-center\",\n  \"left-start\",\n  \"right-end\",\n  \"right-center\",\n  \"right-start\",\n  \"center\"\n];\n\nexport type PlacementType =\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"bottom-center\"\n  | \"top-start\"\n  | \"top-center\"\n  | \"top-end\"\n  | \"left-end\"\n  | \"left-center\"\n  | \"left-start\"\n  | \"right-end\"\n  | \"right-center\"\n  | \"right-start\"\n  | \"center\";\n","import { createElement, forwardRef } from \"react\";\nimport { BoundSide, BoundSideType } from \"./Sides\";\nimport { LayerSide } from \"./types\";\n\nconst LEFT = \"left\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  borderWidth: number\n) {\n  const map = {\n    [BOTTOM]: `0 ${-borderWidth} ${sizeB} ${sizeA}`,\n    [TOP]: `0 0 ${sizeB} ${sizeA + borderWidth}`,\n    [RIGHT]: `${-borderWidth} 0 ${sizeA} ${sizeB}`,\n    [LEFT]: `0 0 ${sizeA + borderWidth} ${sizeB}`\n  };\n\n  return map[side.prop];\n}\n\nfunction getTrianglePath(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  roundness: number,\n  angle: number\n) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A = {\n    [BOTTOM]: [0, sizeA],\n    [TOP]: [0, 0],\n    [RIGHT]: [sizeA, sizeB],\n    [LEFT]: [0, sizeB]\n  }[side.prop].join(\" \");\n\n  const B = side.isHorizontal ? `V 0` : `H ${sizeB}`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C = {\n    [BOTTOM]: [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0],\n    [TOP]: [\n      \"C\",\n      c1A,\n      sizeA - c1B,\n      cPoint + relativeRoundness,\n      sizeA,\n      cPoint,\n      sizeA\n    ],\n    [RIGHT]: [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint],\n    [LEFT]: [\n      \"C\",\n      sizeA - c1B,\n      sizeB - c1A,\n      sizeA,\n      cPoint - relativeRoundness,\n      sizeA,\n      cPoint\n    ]\n  }[side.prop].join(\" \");\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D = {\n    [BOTTOM]: [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A],\n    [TOP]: [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A],\n    [RIGHT]: [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A],\n    [LEFT]: [\n      \"C\",\n      sizeA,\n      cPoint + relativeRoundness,\n      sizeA - d1B,\n      sizeB - d1A,\n      A\n    ]\n  }[side.prop].join(\" \");\n\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(\n  sizeA: number,\n  sizeB: number,\n  borderWidth: number,\n  side: BoundSideType,\n  angle: number\n) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  const [A, B] = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth];\n\n  if (side.isHorizontal) {\n    return [\n      \"M\",\n      A,\n      borderWidth,\n      \"V\",\n      sizeB - borderWidth,\n      \"L\",\n      B,\n      sizeB - borderWidth - borderOffset,\n      \"V\",\n      borderOffset + borderWidth,\n      \"Z\"\n    ].join(\" \");\n  }\n\n  return [\n    \"M\",\n    borderWidth,\n    A,\n    \"H\",\n    sizeB - borderWidth,\n    \"L\",\n    sizeB - borderWidth - borderOffset,\n    B,\n    \"H\",\n    borderOffset + borderWidth,\n    \"Z\"\n  ].join(\" \");\n}\n\nexport type ArrowProps = React.ComponentPropsWithoutRef<\"svg\"> & {\n  /**\n   * angle of triangle\n   * default is `45`\n   */\n  angle?: number;\n  /**\n   * distance in pixels between point of triangle and layer\n   * default is `8`\n   */\n  size?: number;\n  /**\n   * roundness of the point of the arrow\n   * range: 0 - 1\n   * default is `0`\n   */\n  roundness?: number;\n  /**\n   * width of the layers border\n   * default is `0`\n   */\n  borderWidth?: number;\n  /**\n   * color of the layers border\n   * default is `\"black\"`\n   */\n  borderColor?: string;\n  /**\n   * background-color of the layer\n   * default is `\"white\"`\n   */\n  backgroundColor?: string;\n  /**\n   * Given by `useLayer()` and determines the direction the arrow should\n   * be pointing to\n   */\n  layerSide?: LayerSide;\n};\n\nexport const Arrow = forwardRef<SVGSVGElement, ArrowProps>(function Arrow(\n  {\n    size = 8,\n    angle = 45,\n    borderWidth = 0,\n    borderColor = \"black\",\n    roundness = 0,\n    backgroundColor = \"white\",\n    layerSide = \"top\",\n    style = {},\n    ...rest\n  },\n  ref\n) {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const side = BoundSide[layerSide];\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  const maxSize = Math.max(sizeA, sizeB);\n\n  return createElement(\n    \"svg\",\n    {\n      ref,\n      ...rest,\n      style: {\n        ...style,\n        transform: `translate${side.isHorizontal ? \"Y\" : \"X\"}(-50%)`\n      },\n      width: maxSize,\n      height: maxSize,\n      preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n      viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n    },\n    createElement(\"path\", {\n      fill: backgroundColor,\n      strokeWidth: borderWidth,\n      stroke: borderColor,\n      d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n    }),\n    createElement(\"path\", {\n      fill: backgroundColor,\n      d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n    })\n  );\n});\n","import { useState, useRef, useCallback, useEffect, MouseEvent } from \"react\";\n\nexport type UseHoverOptions = {\n  /**\n   * Amount of milliseconds to wait while hovering before opening.\n   * Default is `0`\n   */\n  delayEnter?: number;\n  /**\n   * Amount of milliseconds to wait when mouse has left the trigger before closing.\n   * Default is `0`\n   */\n  delayLeave?: number;\n  /**\n   * Determines whether the layer should hide when the user starts scrolling.\n   * Default is `true`\n   */\n  hideOnScroll?: boolean;\n};\n\nexport type PlainCallback = (...args: any[]) => void;\n\nexport type UseHoverProps = {\n  onMouseEnter: PlainCallback;\n  onMouseLeave: PlainCallback;\n  onTouchStart: PlainCallback;\n  onTouchMove: PlainCallback;\n  onTouchEnd: PlainCallback;\n};\n\nenum Status {\n  ENTERING,\n  LEAVING,\n  IDLE\n}\n\nexport function useHover({\n  delayEnter = 0,\n  delayLeave = 0,\n  hideOnScroll = true\n}: UseHoverOptions = {}): readonly [boolean, UseHoverProps, () => void] {\n  const [show, setShow] = useState(false);\n\n  const timeout = useRef<number | null>(null);\n\n  const status = useRef<Status>(Status.IDLE);\n\n  const hasTouchMoved = useRef<boolean>(false);\n\n  const removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current!);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = window.setTimeout(() => {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_: MouseEvent<any>, immediate?: boolean) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = window.setTimeout(() => {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  }\n\n  // make sure to clear timeout on unmount\n  useEffect(() => {\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n\n  const hoverProps: UseHoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  return [show, hoverProps, () => onMouseLeave(null!, true)] as const;\n}\n","import { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    var isMounted = useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n","import { __values } from 'tslib';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useId } from '../../utils/use-id.mjs';\n\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useId();\n    var context = useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            var e_1, _a;\n            presenceChildren.set(childId, true);\n            try {\n                for (var _b = __values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var isComplete = _c.value;\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { env } from '../../utils/process.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\n\nvar getChildKey = function (child) { return child.key || \"\"; };\nfunction updateChildLookup(children, allChildren) {\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(function () {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function () {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = __spreadArray([], __read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false)\n                    return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    if (env !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n","import { __read } from 'tslib';\nimport sync from 'framesync';\nimport { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\n\nfunction useForceUpdate() {\n    var isMounted = useIsMounted();\n    var _a = __read(useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    var forceRender = useCallback(function () {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    var deferredForceRender = useCallback(function () { return sync.postRender(forceRender); }, [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n"],"names":["useTrackRef","onRefChange","storedReference","useRef","element","current","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","getPixelValue","value","parseFloat","replace","limit","min","max","isSet","mergeRefs","refs","ref","findScrollContainers","environment","result","document","body","getComputedStyle","overflow","overflowX","overflowY","some","prop","includes","push","parentElement","createReferenceError","subject","useTrackElements","enabled","onChange","ResizeObserverPolyfill","overflowContainer","triggerOption","ResizeObserver","polyfill","getResizeObserver","initialState","state","subscriptions","arrowRef","hasTriggerOption","Boolean","scrollContainers","trigger","layer","useMemo","setter","get","set","hasEventSubscriptions","length","removeAllEventSubscriptions","unsubscribe","addEventSubscription","unsubscriber","handleChange","useCallback","closestScrollContainer","Error","scrollOffsets","top","left","scrollLeft","scrollTop","scrollX","scrollY","borderOffsets","borderLeftWidth","borderTopWidth","arrow","addEventListeners","ignoredInitialCall","observer","observe","unobserve","disconnect","addEventListener","removeEventListener","resetWhenReferenceChangedWhileTracking","previous","next","layerRef","previousLayer","getScrollContainers","position","style","triggerRef","previousTrigger","triggerOptionParent","getParent","GroupContext","createContext","GroupProvider","children","registrations","handleRegister","registration","add","delete","createElement","Provider","useGroup","isOpen","onOutsideClick","onParentClose","Set","possibleRegisterFn","useContext","shouldCloseWhenClickedOutside","event","target","clickedOnTrigger","contains","clickedOnLayer","shouldCloseAccordingToChildren","getShouldCloseAccordingToChildren","forEach","closeChild","handleClick","closeOnOutsideClickRefs","OPPOSITES","bottom","right","center","SideBase","opposite","isHorizontal","sizeProp","oppositeSizeProp","cssProp","oppositeCssProp","isCenter","isPush","factor","this","isOppositeDirection","side","createSide","recursive","BoundSide","Side","SIDES","BoundsOffsets","offsets","Object","assign","mergeSmallestSides","boundsOffsets","first","rest","fromEntries","map","boundsOffset","Math","every","filter","sumOfPropertyValues","propertyValues","reduce","sum","propertyValue","boundsToObject","width","height","EMPTY","Bounds","bounds","create","fromElement","options","withTransform","withScrollbars","getBoundingClientRect","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","scrollbarWidth","clientWidth","scrollbarHeight","clientHeight","substract","empty","fromWindow","scrollingElement","documentElement","toObject","merge","partialBoundsOrMergeFn","entries","boundSide","offsetsTo","child","mapSides","mapper","values","Placement","primary","secondary","subjectBounds","layerDimensions","subjectsBounds","_cachedLayerBounds","_cachedContainerOffsets","setSubjectsBounds","dimensions","getLayerBounds","secondaryOffset","arrowOffsetBase","limitMin","limitMax","propertyA","propertyB","sec","triggerValue","arrowCompensation","layerBounds","getLayerCollisionBounds","container","getContainerOffsets","layerOffsetsToScrollContainers","triggerHasBiggerWidth","triggerHasBiggerHeight","allSidesArePositive","negativeSides","surface","containerOffsets","sort","a","PlacementCenter","STYLE_BASE","willChange","Placements","placements","config","getSidesFromPlacementType","type","split","b","arrowOffset","containerOffset","triggerOffset","getListOfPlacements","preferedPlacement","placement","preferredSide","preferY","preferX","triggerIsBigger","placementFrom","list","possiblePlacements","filterPlacementsBySide","findFirstPlacementThatFits","find","fitsContainer","placementWithBiggestVisibleSurface","visibleSurface","findSuitablePlacement","auto","getSecondaryOffset","snap","placementsOnSameSide","indexOf","firstPlacementThatDoesNotFit","secondaryOffsetSide","getStyles","layerStyleBase","sizeProperty","negativeOffset","sideA","sideB","offsetA","offsetB","getNegativeOffsetBetweenLayerCenterAndTrigger","primarySide","secondarySide","secondaryValue","getArrowStyle","parent","getHasDisappeared","offsetsToScrollContainers","suitablePlacement","styles","layerSide","hasDisappeared","SubjectsBounds","getTriggerBounds","allContainers","scrollContainer","GLOBAL_CONTAINER","DEFAULT_OPTIONS","undefined","useLayer","onDisappear","useState","setState","triggerBoundsRef","lastState","currentState","useLastState","repositioningToken","cancelled","handlePositioning","getBounds","newState","didStateChange","token","Promise","resolve","then","props","triggerProps","layerProps","arrowProps","triggerBounds","renderLayer","createPortal","HTMLElement","getElementById","DEFAULT_CONTAINER_ID","id","cssText","appendChild","getContainerElement","LEFT","TOP","BOTTOM","RIGHT","getWidthBasedOnAngle","angle","size","tan","PI","getViewBox","sizeA","sizeB","borderWidth","getTrianglePath","roundness","relativeRoundness","A","join","B","cPoint","c1A","c1B","C","d1A","d1B","getBorderMaskPath","borderOffset","Status","Arrow","forwardRef","borderColor","backgroundColor","maxSize","transform","preserveAspectRatio","viewBox","fill","strokeWidth","stroke","d","useIsMounted","isMounted","PresenceChild","_a","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","presenceChildren","newChildrenMap","context","childId","e_1","_b","_c","done","e_1_1","error","return","call","register","_","key","PresenceContext","Map","getChildKey","AnimatePresence","exitBeforeEnter","_d","forcedRenderCount","setForcedRenderCount","forceRender","postRender","useForceUpdate","forceRenderLayoutGroup","LayoutGroupContext","filteredChildren","filtered","Children","isValidElement","onlyElements","childrenToRender","exiting","presentChildren","allChildren","isInitialRender","updateChildLookup","clear","presentKeys","targetKeys","numPresent","i","insertionIndex","splice","removeIndex","findIndex","presentChild","has","console","warn","cloneElement"],"sourceRoot":""}